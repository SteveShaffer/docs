"""
Used to authorize access to a given query, mutation, or field
based on permissions set in the user token.
for example, to restrict a field foo to superadmins, add
  foo: Foo @scopes(scopes: ["superadmin"])
Permission strings must EXACTLY match the permission objects defined
in functional-permissions-lib. If the user does not have all required
permissions, the field will contain null and the errors list will
have an "access denied" error message.
"""
directive @scopes(
  """List of one or more scopes required for the field"""
  scopes: [String!]!

  """
  Whether or not to require _all_ scopes listed or only any one of them.
  Default is All.
  """
  require: ScopeRequirement = All
) on QUERY | MUTATION | FIELD

"""
Used to require authentication and to enforce organization-level
authorization. This directive, with default parameters, is applied by
default to all queries and mutations. Parameter values can be overridden
by setting it explicitly on a field.
The @noAuth directive can be explicitly used on fields that do not
require authentication.
Examples:
 Allow org-less tokens to access objects of type TemporalDataObject
 based on the id parameter.
  @auth(allowOrgless: true, objectAuthType: TemporalDataObject)
Allow org-less tokens to use the field with no object restrictions.
The @scopes directive might still apply.
  @auth(allowOrgless: true, skipObjectAuthorization: true)
Allow org-less tokens to use the field if the ID referenced in parentId
is in the allowed set of TemporalDataObjects. Useful for something like
createAsset.
  @auth(allowOrgless: true, objectAuthType: TemporalDataObject,
        objectAuthIdParam: parentId)
"""
directive @auth(
  """Whether or not to allow access for org-less (engine) tokens"""
  allowOrgless: Boolean = true

  """
  Whether or not to skip object-level authorization for org-less tokens.
  Use with caution.
  """
  skipObjectAuthorization: Boolean = false

  """
  The type of object that object-level access controls should apply to.
  Must be set if allowOrgless is true and skipObjectAuthorization is false.
  """
  objectAuthType: AuthObjectType

  """
  The name of the field parameter containing id(s) to query for.
  Object-level authorization will authorize this value against the list of
  allowed object resources for the token.
  """
  objectAuthIdParam: String = "id"
) on QUERY | MUTATION | FIELD

"""
Used to explicitly declare that a given field does not require authentication.
Use with caution.
"""
directive @noAuth on QUERY | MUTATION | FIELD

directive @tokenType(type: TokenType!) on QUERY | MUTATION | FIELD

directive @log on QUERY | MUTATION | FIELD

directive @noLog on QUERY | MUTATION | FIELD

directive @featureFlag(
  """
  default value for the feature flag to use if it is not provided
  in configuration or on the org
  """
  defaultValue: Boolean = false

  """
  Optional name for the feature flag. The default will be the
  mutation, query, or field name to which the directive is attached.
  """
  name: String
) on QUERY | MUTATION | FIELD

directive @audit(objectType: String, action: AuditAction, skip: Boolean) on MUTATION

directive @limit(cost: Int) on QUERY | MUTATION | FIELD

input AddLibraryDataset {
  """Id of the selected library"""
  libraryId: ID!

  """List of tdo ids to add to the selected library"""
  tdoIds: [ID]!
}

input AddMediaSegment {
  """ID of the TemporalDataObject container for the segment"""
  containerId: ID!

  """Details for the segment, such as start and stop offset"""
  details: JSON!

  """The url to the segment content."""
  url: String!
}

input AddTask {
  id: ID!
  jobId: ID!
  engineId: ID!
  buildId: ID!
  status: TaskStatus!
  createdDateTime: DateTime!
  payload: JSON
  parentTaskId: ID
}

input AddTasksToJobs {
  tasks: [AddTask!]
}

type AddTasksToJobsError {
  id: ID
  message: String
}

type AddTasksToJobsResponse {
  createdTasks: [Task]
  errors: [AddTasksToJobsError]
}

"""
An application is a set of Veritone functionality that customers can sign up for.
"""
type Application {
  id: ID!
  key: String!
  name: String!
  category: String
  description: String
  iconUrl: String
  iconSvg: String
  url: String
  deploymentModel: DeploymentModel
  createdDateTime: DateTime
  modifiedDateTime: DateTime

  """
  OAuth2 client secret. This field is server-generated and is only
  returned on application creation.
  """
  clientSecret(password: String): String

  """OAuth2 redirect URLs"""
  oauth2RedirectUrls: [String]
  organizationId: ID!
  status: ApplicationStatus
  permissionsRequired: [String]
  contextMenuExtensions: ContextMenuExtensionList
  validStateActions: [ApplicationStateAction]
}

type ApplicationList implements Page {
  records: [Application]

  """The starting index for records that were returned in this query."""
  offset: Int!

  """
  Maximum number of results that were retrieved in this query; page size
  """
  limit: Int!

  """Number of records returned in this response"""
  count: Int
}

"""TODO"""
type ApplicationPlatform {
  """The application platform ID"""
  id: ID

  """Platform type, such as TODO"""
  platformType: String

  """The application platform URL."""
  platformUrl: String
}

enum ApplicationStateAction {
  approve
  edit
  delete
  deploy
  disable
  enable
  reject
  submit
  undelete
}

"""
Set of possible states for a custom application.
The application state determines whether or not it is available in production
and the actions that can be taken on it.
"""
enum ApplicationStatus {
  """The application is active (production state)"""
  active

  """The application is in draft state during test and development"""
  draft

  """
  The application has been deleted and is no longer available for any purpose
  """
  deleted

  """The application is awaiting approval."""
  pending

  """
  The application has been rejected and must be modified and re-submitted.
  """
  rejected

  """The application has been approved and can now be deployed."""
  approved

  """The application has been disabled, but not deleted."""
  disabled
}

input ApplicationWorkflow {
  id: ID!
  action: ApplicationWorkflowAction!
}

enum ApplicationWorkflowAction {
  submit
  approve
  reject
  deploy
  enable
  disable
  undelete
}

"""
An asset represents a single unit of data, such as a file or URL,
and basic metadata about that data. An asset must be contained within
a TemporalDataObject.
"""
type Asset {
  """The asset ID"""
  id: ID!

  """Asset name, such as a file name."""
  name: String

  """Asset content type. Must be a valid MIME type string."""
  contentType: String

  """An optional description of the asset"""
  description: String
  createdDateTime: DateTime
  modifiedDateTime: DateTime

  """Freeform metadata in JSON format."""
  jsondata: JSON

  """The ID of the TemporalDataObject that contains this asset"""
  containerId: ID!

  """The TemporalDataObject that contains this asset"""
  container: TemporalDataObject

  """
  The asset's URI. If a file is provided on asset creation, this URI
  point to the object in Veritone's object storage.
  """
  uri: String

  """A signed version of the asset's URI"""
  signedUri: String

  """
  The asset type, such as `media`, `transcript`, or `text`.
  The asset type determines which engines are able to operate on it.
  For example, a transcription engine requires a `media` asset.
  Engines that record their results in an asset typically set the type
  accordingly, such as `transcript`.
  """
  type: String!

  """Deprecated alias for type"""
  assetType: String

  """
  Freeform application-defined metadata. This field may contain information
  specific to the object type, such as image or video metadata.
  """
  details(
    """
    optionally, specify a path to retrieve only a specific property
    within the details JSON
    """
    path: String
  ): JSON

  """Metadata as raw JSON string"""
  jsonstring(indent: Int = 2): String

  """
  A structured containing metadata about a file. This will be set if the
  asset was created by uploading a file.
  """
  fileData: AssetFileData

  """
  A structure containing metadata about the source engine and task. This will
  be set if the asset was created by an engine.
  """
  sourceData: AssetSourceData

  """
  Asset transform. The transformation function to be used with the asset.
  It can be XML to JSON
  """
  transform(transformFunction: TransformFunction!): String

  """
  A Boolean indicating whether or not this asset was created by editing
  another asset.
  """
  isUserEdited: Boolean
}

enum AssetCreationMode {
  create
  append
  replace
}

"""A structured containing metadata about an asset file."""
type AssetFileData {
  """The MD5 checksum of the file"""
  md5sum: String

  """The file size in bytes"""
  size: Int

  """Original file URI, if provided on asset creation"""
  originalFileUri: String
}

type AssetList implements Page {
  records: [Asset]

  """The starting index for records that were returned in this query."""
  offset: Int!
  limit: Int!

  """Number of records returned in this response"""
  count: Int
}

enum AssetOrderBy {
  createdDateTime
  assetType
  contentType
}

"""
A structure containing metadata about the source engine and task for an asset.
"""
type AssetSourceData {
  """The name of the asset source engine or engine category"""
  name: String

  """ID of the specific task that created the asset"""
  taskId: ID

  """The specific task that created the asset"""
  task: Task

  """The ID of the engine that created the asset"""
  engineId: ID

  """The engine that created the asset"""
  engine: Engine

  """The ID of the source from which this asset was generated or stamped."""
  sourceId: ID

  """
  ID of the schema describing this asset, if there is one.
  Typically applies only to assets of type "content-template".
  """
  schemaId: ID

  """The schema definition, if there is one"""
  schema: Schema
}

enum AuditAction {
  Create
  Update
  Delete
}

type AuditLogEntry {
  """ID of the organization that generated the audit entry."""
  organizationId: ID

  """
  The type of the object involved in the audit action, such as `Watchlist`
  or `TemporalDataObject`.
  """
  objectType: String

  """
  The ID of the object involved in the audit action. The format of this ID
  varies by object type.
  """
  objectId: ID

  """The unique ID of the audit log entry."""
  id: ID!

  """The event type, such as `Create`, `Update`, or `Delete`."""
  eventType: String

  """
  User name or ID that generated the audit entry. This might be an API key.
  """
  userName: String

  """Indicates whether or not the attempted action was successful."""
  success: Boolean

  """IP address of the client that generated the audit action."""
  clientIpAddress: String

  """HTTP user agent of the client that generated the audit action."""
  clientUserAgent: String
  description: String

  """Date/time at which the audit log entry was created."""
  createdDateTime: DateTime!
}

type AuditLogEntryList implements Page {
  records: [AuditLogEntry!]!

  """Count of records in this page. Will be less than or equal to `limit`."""
  count: Int

  """Offset used in the query that generated this page."""
  offset: Int!

  """Limit used in the query that generated this page."""
  limit: Int!

  """
  `toDateTime` value of the query that generated this page.
  Useful when a default was applied.
  """
  toDateTime: DateTime

  """
  `fromDateTime` value of the query that generated this page.
  Useful when a default was applied.
  """
  fromDateTime: DateTime
}

"""Specifies an "order by" entry in the `auditLog` query"""
input AuditLogOrderBy {
  field: AuditLogOrderByField
  direction: OrderDirection
}

"""Fields that can be set in an `auditLog` `orderBy` parameter"""
enum AuditLogOrderByField {
  id
  objectId
  objectType
  createdDateTime
  eventType
  userName
  clientIpAddress
  clientUserAgent
  success
}

enum AuthObjectType {
  TemporalDataObject
  Job
  Task
  Folder
}

type AutocompleteFieldConfig {
  autocompleteField: String
  indexField: String
}

"""Type representing a boolean property"""
type BooleanProperty implements Property {
  name: String!
  value: Boolean
}

type Build {
  id: ID!
  name: String
  description: String

  """Date and date build was created"""
  createdDateTime: DateTime

  """Date and time build was last modified"""
  modifiedDateTime: DateTime
  createdBy: String
  modifiedBy: String

  """The ID of the engine this build is for"""
  engineId: ID!

  """The engine this build is for"""
  engine: Engine
  price: Int
  validateUri: String
  executeUri: String

  """Engine build status:"""
  status: BuildStatus

  """URL to the Docker image for this engine build, if applicable"""
  dockerImage: String
  runtime: JSON
  version: String
  report: JSON

  """
  The entire manifest, supplied by the engine developer, that describes
  the engine's capabilities and requirements and is used by the platform
  system to build and execute the engine.
  """
  manifest: JSON
  preferredInputFormat: String
  supportedInputFormats: [String!]
  outputFormats: [String!]

  """
  List of IDs of source types that the engine supports.
  Applies only to adapter engines that ingest data from a source.
  Will be a list of IDs of SourceType objects.
  """
  supportedSourceTypes: [String!]

  """Used to give a default action choice"""
  primaryAction: BuildUpdateAction

  """Used to give secondary action choices"""
  secondaryActions: [BuildUpdateAction]

  """Contains all valid action choices"""
  validStateActions: [BuildUpdateAction]
}

type BuildList implements Page {
  records: [Build]

  """The starting index for records that were returned in this query."""
  offset: Int!
  limit: Int!

  """Number of records returned in this response"""
  count: Int
}

"""Valid strings for the `Build.status` field."""
enum BuildStatus {
  """The build has been approved and is ready for deployment"""
  approved

  """The build is available for deployment"""
  available

  """The build has been soft-deleted."""
  deleted

  """The build is being deployed."""
  deploying

  """The build has been deployed. There can be only one deployed build."""
  deployed

  """The build files are being fetched from their source."""
  fetching

  """The build failed validation checks. See build report for details."""
  invalid

  """
  The build is deployed but has been paused. Engine processing will not
  proceed until the build is un-paused.
  """
  paused

  """
  The build has been created but is still pending approval and other
  workflow steps.
  """
  pending

  """The build has been successfully uploaded to the build repository."""
  uploaded

  """Deployment has failed"""
  deployFailed
}

enum BuildUpdateAction {
  deploy
  pause
  unpause
  approve
  disapprove
  invalidate
  submit
  upload
  delete
}

input BulkDeleteContextMenuExtensions {
  """List of IDs of context menu extensions to delete"""
  ids: [ID!]
}

input BulkUpdateWatchlist {
  """
  New stop date for watchlist. Currently, this is the only
  field that can be updated.
  """
  stopDate: DateTime
}

input BulkUpdateWatchlistFilter {
  """List of IDs of watchlists to update"""
  ids: [ID!]
}

type Bundle {
  id: ID!
  organizationId: ID
  clusterId: ID
  nodeId: ID
  name: String
  externalCredentialId: ID
  testRun: Boolean
  selectDetail: BundleSelectDetail
  selectCategory: String
  bundleResults: BundleResults
  bundleStarted: DateTime
  previousBundleStarted: DateTime
  bundleCompleted: DateTime
  deletedDate: DateTime
  createdDate: DateTime
  updatedDate: DateTime
  scheduleDefinition: BundleScheduleDefinition
  nextScheduledTime: DateTime
}

input bundleError {
  error: String!
}

type BundleError {
  error: String!
}

input bundleResults {
  found: Int!
  completed: Int!
  errors: bundleError!
}

type BundleResults {
  found: Int!
  completed: Int!
  errors: BundleError!
}

type BundleScheduleDefinition {
  recurringStartTime: DateTime
  recurringEndTime: DateTime
  repeatDaysTimeInMinutes: Int
  repeatDaysOfWeek: [Int]
  repeatDaysOfMonth: [Int]
  repeatMinutes: Int
}

type BundleSelectDetail {
  category: String!

  """Array of file types to include."""
  select: [String!]

  """Array of paths to search from."""
  paths: [String!]

  """Array of files to search from."""
  files: [String]

  """Array of tasks to run for each job."""
  tasks: [BundleSelectDetailTask]

  """Include items after this time."""
  afterTime: DateTime

  """Include items before this time."""
  beforeTime: DateTime
  recursiveDescent: Boolean!
  service: BundleService
}

type BundleSelectDetailTask {
  """Id of engine."""
  engineId: ID!
}

type BundleService {
  serviceType: String
  region: String
  bucketName: String
}

input BundleStatus {
  bundleStarted: DateTime
  bundleCompleted: DateTime
  bundleResults: bundleResults!
  markAsCompleted: Boolean
}

type Campaign {
  id: ID!
  name: String!
  startDate: DateTime
  stopDate: DateTime
  budget: Int
  organizationId: ID!
  advertiserId: ID
  brandId: ID
  notes: String
}

input ChangePassword {
  """
  The current user's old password. Must be provided even if the
  user is otherwise authenticated as an additional security check.
  """
  oldPassword: String!

  """
  The new password. May be subject to validation rules depending
  on the organization or environment system policy.
  """
  newPassword: String!
}

"""
Object that represents the mapping of clone assets to its parent's assets.
"""
type CloneAssetIdMap {
  """The original asset ID (within the cloned asset container)."""
  oldAssetId: ID!

  """The new asset ID (within the clone asset container)."""
  newAssetId: ID!
}

"""Metadata that represents a clone of a recording."""
type CloneData implements Metadata {
  """Timestamp when the recording was cloned"""
  date: String

  """The ID of the asset container this was cloned from"""
  originalId: String!

  """Clone blobs flag"""
  cloneBlobs: Boolean

  """Map of asset IDs from the clone to the parent."""
  assetIdMap(
    """Provide an ID to retrieve mappings for specific old asset."""
    oldAssetId: ID

    """Provide an ID to retrieve mappings for a specific new asset."""
    newAssetId: ID
  ): [CloneAssetIdMap]
  name: String!
}

type CloneRequest {
  id: ID!
  sourceApplicationId: ID!
  destinationApplicationId: ID!
  numberOfRecordings: Int
  numberOfCompletedRecordings: Int
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  status: String
  percentage: Int
}

type CloneRequestList implements Page {
  records: [CloneRequest]
  count: Int
  offset: Int!
  limit: Int!
}

input CloneScheduledJob {
  id: ID!

  """
  Organization ID. Used only by Veritone platform components.
  Other clients should not attempt to send this field. Any value sent
  will be ignored.
  """
  organizationId: ID
}

type Cluster {
  id: ID!
  nodes: ClusterNodeList
  name: String
  isPublic: Boolean
  type: ClusterType
  organizationId: ID
  allowedEngines: [ID!]
  containerTag: String
  paused: Boolean
  memorySizeBytes: Float
  storageSizeBytes: Float
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  deletedDateTime: DateTime
  cachedDateTime: DateTime
  default: Boolean
  bypassAllowedEngines: Boolean
  collaborators: ClusterCollaboratorList

  """Retrieve jobs"""
  jobs(
    """Provide an ID to retrieve a single specific job."""
    id: ID

    """Provide a list of status strings to filter by status"""
    status: [JobStatusFilter!]

    """
    Provide an offset to skip to a certain element in the result, for paging.
    """
    offset: Int = 0

    """
    Specify the maximum number of results to included in this response, or page size.
    """
    limit: Int = 30

    """
    Provide an application ID to filter jobs for a given application.
    Defaults to the user's own application.
    """
    applicationId: ID

    """
    Provide a target ID to get the set of jobs running against a particular TDO.
    """
    targetId: ID

    """
    Provide a list of scheduled job IDs to get jobs associated with the scheduled jobs
    """
    scheduledJobIds: [ID!]

    """
    Provide sort information. The default is to sort by
    createdDateTime descending.
    """
    orderBy: [JobSortField!]

    """
    Filter by date/time field. If a filter is not provided, a default of
    `createdDateTime` between now and 1 day ago will be applied.
    """
    dateTimeFilter: [JobDateTimeFilter!]

    """
    Provide list of application IDs to filter jobs.
    Defaults to the user's own application.
    """
    applicationIds: [ID]
  ): JobList!
  tasks(
    """Specify a list of job status strings to filter by status"""
    status: [TaskStatus!]

    """
    Provide an offset to skip to a certain element in the result, for paging.
    """
    offset: Int = 0

    """Maximum number of results to retrieve in this query"""
    limit: Int = 30

    """Specify an ID to retrieve a single specific task"""
    id: ID

    """
    If a filter is not provided, a default of `createdDateTime` between
    now and 1 day ago will be applied.
    """
    dateTimeFilter: [TaskDateTimeFilter!]
  ): TaskList!

  """Retrieve current subscriptions for events on this cluster."""
  subscriptions: ClusterSubscriptionList!

  """Retrieve tags for this cluster"""
  tags: [String!]

  """Retrieve the cluster's current status"""
  status: ClusterStatus!

  """Cluster configuration overrides"""
  clusterConfig: JSON

  """State information about the cluster, conforming to a stable schema."""
  state: JSON

  """Date and time at which the state was last updated the system."""
  stateLastUpdatedDateTime: DateTime

  """media storage option"""
  mediaStorage: MediaStorageOption!

  """media storage path -- applies to edge only"""
  mediaStoragePath: String

  """ID of the management node. Applies to portable/edge clusters only."""
  managementNodeID: ID

  """
  Optionally, specify a time at which the edge cluster should
  be restarted daily. Applies only to edge clusters.
  """
  restartTimeUTC: Time

  """Retrieve the cluster's service token"""
  serviceToken: String
}

"""
A source ACL grants a single organization limited rights to a private clusters
"""
type ClusterCollaborator {
  """The permission granted."""
  permission: ClusterPermission!

  """Organization ID the cluster was shared with"""
  organizationId: ID!

  """The organization the cluster was shared with"""
  organization: Organization
}

type ClusterCollaboratorList implements Page {
  records: [ClusterCollaborator!]!
  offset: Int!
  limit: Int!
  count: Int
}

enum ClusterDateTimeField {
  createdDateTime
  modifiedDateTime
  stateLastUpdatedDateTime
}

input ClusterDateTimeFilter {
  toDateTime: DateTime
  fromDateTime: DateTime
  field: ClusterDateTimeField!
}

type ClusterList implements Page {
  records: [Cluster!]!
  count: Int!
  offset: Int!
  limit: Int!
}

type ClusterNode {
  id: ID!
  clusterId: ID
  cluster: Cluster
  name: String
  metrics: JSON

  """Cluster configuration overrides"""
  nodeConfig: JSON
  paused: Boolean
}

type ClusterNodeList implements Page {
  records: [ClusterNode]
  count: Int!
  offset: Int!
  limit: Int!
}

input ClusterOrderBy {
  field: ClusterOrderByField!
  direction: OrderDirection = desc
}

enum ClusterOrderByField {
  name
  createdDateTime
  modifiedDateTime
  stateLastUpdatedDateTime
}

enum ClusterPermission {
  owner
  viewer
}

enum ClusterSize {
  small
  medium
  large
}

enum ClusterStatus {
  pending
  active
  deploying
  online
  paused
  terminated
}

type ClusterSubscription {
  userId: ID!
  emailAddress: String!
  id: ID!
  createdDateTime: DateTime!
  modifiedDateTime: DateTime!
  isActive: Boolean!
}

type ClusterSubscriptionList implements Page {
  records: [ClusterSubscription!]!
  count: Int!
  offset: Int!
  limit: Int!
}

enum ClusterType {
  """Amazon Machine Image"""
  ami

  """Real-Time"""
  RT

  """On Premise"""
  OnPrem
}

type CognitiveSearch {
  id: ID!

  """A recursive tree structure defining the search criteria"""
  profile: JSON

  """
  ID of the mention status to set on each mention generated as a result
  of a match against this search
  """
  mentionStatusId: ID

  """
  The mention status to set on each mention generated as a result
  of a match against this search
  """
  mentionStatus: MentionStatus

  """
  The raw query. Read-only and server-generated based on the search profile.
  """
  query: JSON
}

type CognitiveSearchCondition {
  engineCategoryId: ID!
  state: JSON!
}

type CognitiveSearchProfile {
  and: [CognitiveSearchProfile!]
  or: [CognitiveSearchProfile!]
  condition: CognitiveSearchCondition
  jsondata: JSON
}

type Collection {
  id: ID!
  name: String!

  """A url to get the collection image"""
  imageUrl: String

  """
  A sigend url to get the collection image. It will only be signed if it is an s3 url.
  """
  signedImageUrl: String
  ownerId: ID
  description: String
  organization: Organization
  organizationId: ID!
  orgSharing: Boolean
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  programCount: Int
  itemCount: Int
  typeId: ID
  isActive: Boolean
  widgets(
    """
    Provide an offset to skip to a certain element in the result, for paging.
    """
    offset: Int = 0

    """Maximum number of results to retrieve in this query; page size"""
    limit: Int = 30
    id: ID
  ): WidgetList
}

type CollectionList implements Page {
  records: [Collection]

  """
  Provide an offset to skip to a certain element in the result, for paging.
  """
  offset: Int!

  """
  Maximum number of results that were retrieved in this query; page size
  """
  limit: Int!

  """Number of records returned in this response"""
  count: Int
}

type CollectionMention {
  """id of the collection"""
  folderId: ID!

  """id of the mention"""
  mentionId: ID!
}

input CollectionMentionInput {
  """id of the collection"""
  folderId: ID!

  """id of the mention"""
  mentionId: ID!
}

type CompoundProperty implements Property {
  name: String!
  value: KVP
}

type ContextMenuExtension {
  id: ID!
  label: String!
  url: String!
}

type ContextMenuExtensionList {
  mentions: [ContextMenuExtension]
  tdos: [ContextMenuExtension]
  watchlists: [ContextMenuExtension]
  collections: [ContextMenuExtension]
}

input CreateAllPipelineJobs {
  jobPipelineId: ID!
  jobPipelineStage: Int = 1

  """
  Optional data about the job target,
  a TemporalDataObject. If this field is
  not specified then a suitable
  object will be created automatically.
  """
  targetInfo: CreateAllPipelineJobsTargetInfo

  """Job payload"""
  payload: JSON

  """
  Supply this value if and only if the job pipeline
  was started as part of a scheduled job.
  """
  scheduledJobId: ID
  organizationId: ID
  applicationId: ID
}

input CreateAllPipelineJobsTargetInfo {
  """
  ID of the target object for the job pipeline,
  typically that of a TemporalDataObject
  """
  targetId: ID!
  startOffsetMs: Int
  endOffsetMs: Int
}

input CreateApplication {
  name: String!
  key: String!
  category: String
  description: String!
  iconUrl: String
  iconSvg: String
  url: String!
  oauth2RedirectUrls: [String]
  checkPermissions: Boolean!
  permissionsRequired: [String]
  deploymentModel: DeploymentModel
  contextMenuExtensions: CreateContextMenuExtensions
}

input CreateAsset {
  """ID of the parent container, a TemporalDataObject, for the new asset"""
  containerId: ID!

  """A valid MIME type"""
  contentType: String

  """An optional description for the asset"""
  description: String

  """A file to upload. Use multipart form POST to submit this field."""
  file: UploadedFile

  """Optional expected checksum for the file"""
  md5sum: String

  """Asset type - deprecated (use type)"""
  assetType: String

  """The asset type. Either this or assetType must be provided."""
  type: String

  """
  URI to the asset data. Optional -- if a file is provided, the URI
  will be computed by the server.
  """
  uri: String

  """Optionally, set attributes about the file"""
  fileData: SetAssetFileData

  """Optionally, set attributes about the source engine and task"""
  sourceData: SetAssetSourceData

  """Application- or type-specific metadata"""
  details: JSON

  """File or other name"""
  name: String

  """Deprecated. Set `fileData`, `sourceData`, or `details` instead."""
  jsondata: JSON

  """
  if true, sets the new asset to be the primary asset of its type.
  Only certain asset types, such as "media" and "transcript",
  can have primary assets.
  """
  setAsPrimary: Boolean = false

  """Set to true if this asset was created by editing another asset."""
  isUserEdited: Boolean = false

  """
  Set to true if the container stopDateTime needs to be updated by
  the duration of the asset
  """
  updateContainerStopDateTime: Boolean = false
}

input CreateBuild {
  engineId: ID!
  taskRuntime: JSON
  dockerImage: String
  manifest: JSON
}

input CreateCluster {
  name: String!
  allowedEngines: [String]!
  dockerCredentials: JSON!
  type: ClusterType
  containerTag: String
  paused: Boolean

  """
  Specify memory size in raw bytes or in human-readable
  format such as 8gb, 1024mb, etc.
  """
  memorySize: String

  """
  Specify storage size in raw bytes or in human-readable
  format such as 8gb, 1024mb, etc.
  """
  storageSize: String
  bypassAllowedEngines: Boolean

  """
  Permissions granted to other organizations. Only the cluster owner
  can view or edit this field.
  """
  collaborators: [CreateClusterCollaborator!]

  """Set subscriptions on the cluster."""
  subscriptions: [CreateClusterSubscription]

  """Tags for cluster"""
  tags: [String]

  """Status for cluster"""
  status: ClusterStatus

  """Update the cluster config"""
  clusterConfig: JSON

  """media storage type (edge or core)"""
  mediaStorage: MediaStorageOption = core

  """Media storage path. Optional -- use only for edge."""
  mediaStoragePath: String

  """
  Optionally, specify a time at which the edge cluster should
  be restarted daily. Applies only to edge clusters.
  """
  restartTimeUTC: Time

  """Optionally, specify an api-token for cluster"""
  serviceToken: String
}

input CreateClusterCollaborator {
  """ID of the organization to share"""
  organizationId: ID!

  """
  Permission to grant cluster. Can be `viewer`.
  Set to `none` to revoke permissions for this organization.
  """
  permission: SetClusterPermission!
}

input CreateClusterNode {
  name: String
  clusterId: ID
  metrics: CreateMetrics!
  containerTag: String
  offlineBrowsing: Boolean
  storagePresent: Boolean

  """Update the cluster node config"""
  nodeConfig: JSON
}

input CreateClusterSubscription {
  userId: ID!
  isActive: Boolean = true
}

input CreateCognitiveSearch {
  profile: JSON
  jsonstring: String
  mentionStatusId: ID!
  watchlistId: ID!
}

input CreateCognitiveSearchCondition {
  engineCategoryId: ID!
  state: JSON!
}

input CreateCognitiveSearchInWatchlist {
  profile: JSON

  """String with JSON containing the cognitive search profiles"""
  jsonstring: String
  mentionStatusId: ID!
}

input CreateCognitiveSearchProfile {
  and: [CreateCognitiveSearchProfile]
  or: [CreateCognitiveSearchProfile]
  condition: CreateCognitiveSearchCondition
}

input CreateCollection {
  """the name of the collection"""
  name: String!

  """description of the collection"""
  folderDescription: String

  """Collection image"""
  image: String
}

input CreateCollectionMentions {
  """id of the collection"""
  folderId: ID!

  """ids of the mentions"""
  mentionIds: [ID!]!
}

input CreateContextMenuExtension {
  label: String!
  url: String!
}

input CreateContextMenuExtensions {
  mentions: [CreateContextMenuExtension] = []
  tdos: [CreateContextMenuExtension] = []
  watchlists: [CreateContextMenuExtension] = []
  collections: [CreateContextMenuExtension] = []
}

input CreateCreative {
  name: String!
  keywords: String
  brandId: ID
  advertiserId: ID
}

input CreateDataRegistry {
  """Optionally, provide a forced ID. It must be a valid UUID."""
  id: ID

  """Provide a name for the new data registry."""
  name: String!

  """Provide a description for the new data registry."""
  description: String!

  """
  Provide source information. If in doubt, set this
  field to the same value as name.
  """
  source: String!

  """
  Defines a Veritone platform system data registry.
  Only platform components can set this value.
  """
  isSystem: Boolean
}

input CreateDatasetConfidence {
  """
  Mininum Confidence Filter. Sources with confidence lower than this will be ignore
  """
  min: Float = 0

  """
  Maximum Confidence Filter. Sources with confidence higher than this will be ignore
  """
  max: Float = 100

  """allow sources with null confidence values"""
  allowNull: Boolean = true
}

type CreatedMediaShare {
  id: String!
  url: String!
}

"""Input fields used to create a new engine."""
input CreateEngine {
  """Optional given id"""
  id: ID

  """
  Indicates whether or not the engine should be public -- visible to and
  usable by users outside the creator's organization.
  Typically an engine should not be made public until it has been fully
  configured and tested in production.
  """
  isPublic: Boolean = false

  """Human-readable name for the engine"""
  name: String!

  """An optional description for the engine."""
  description: String

  """The engine category"""
  categoryId: String!

  """
  The engine deployment model. See the DeploymentModel enum for options.
  """
  deploymentModel: DeploymentModel!

  """An optional price indicator for the engine."""
  price: Int

  """
  Optionally, supply custom fields that the user can set when launching
  the engine. See developer documentation for details.
  """
  fields: [CreateEngineField!]

  """The path for an icon image"""
  iconPath: String

  """The path for a logo image"""
  logoPath: String

  """Whether or not the engine requires a library."""
  libraryRequired: Boolean = false

  """Whether or not the engine creates a TDO"""
  createsTDO: Boolean = false
}

input CreateEngineConfiguration {
  sourceId: ID!
  credentialIds: [ID!]
}

input CreateEngineDependency {
  """
  The category type this engine depends on.
  Must be a valid categoryType from an existing EngineCategory.
  """
  dependencyType: String!

  """
  An optional asset type that the engine will expect to have
  been created.
  """
  assetType: String
}

input CreateEngineField {
  """
  Maximum value, in float format. Applies only to fields of type Number.
  """
  max: Float

  """
  Minimum value, in float format. Applies only to fields of type Number.
  """
  min: Float

  """
  Numerical step by which the value should be incremented or decremented in
  the user interface, in float format. Applies only to fields of type Number.
  """
  step: Float

  """The field type."""
  type: EngineFieldType!

  """General information about the field, such as a description."""
  info: String

  """A machine-readable name, or key, for the field."""
  name: String!

  """A human-readable label for the field."""
  label: String!

  """
  A set of allowed values for the field. Applies only to fields of type
  picklist or multi-picklist.
  """
  options: [CreateEngineFieldPicklistOption!]

  """
  An optional default value for the field. Taken in string format, but
  applies to all field types.
  """
  defaultValue: String

  """
  Optional default values to apply to a picklist. This field
  should only be set for a field of type multi-picklist.
  """
  defaultValues: [String!]
}

"""Represents one allowed option in a picklist."""
input CreateEngineFieldPicklistOption {
  """
  The human-readable label for the option, such as "English-US" for a language selector.
  """
  key: String!

  """
  The machine-readable value that will be sent in the engine payload, such as
  "en-us" for a language selector.
  """
  value: String!
}

input CreateEntity {
  name: String!
  description: String
  libraryId: ID!
  profileImageUrl: String

  """
  GraphQL-formatted JSON-like structure containing freeform metadata.
  If a schema is associated with the entity type, the input will be
  validated against the schema. Use this field _or_ `jsonstring`, not both.
  """
  jsondata: JSON

  """
  A string containing valid JSON with freeform metadata.
  If a schema is associated with the entity type, the input will be
  validated against the schema. Use this field _or_ `jsondata`, not both.
  """
  jsonstring: String
  isPublished: Boolean = false
}

input CreateEntityIdentifier {
  entityId: ID!
  identifierTypeId: ID!
  title: String
  isPriority: Boolean
  url: String

  """
  GraphQL-formatted JSON-like structure containing freeform metadata.
  If a schema is associated with the entity type, the input will be
  validated against the schema. Use this field _or_ `jsonstring`, not both.
  """
  jsondata: JSON

  """
  A string containing valid JSON with freeform metadata.
  If a schema is associated with the entity type, the input will be
  validated against the schema. Use this field _or_ `jsondata`, not both.
  """
  jsonstring: String
  contentType: String!
  file: UploadedFile
  entityType: CreateEntityType

  """
  If the entity identifier type is image, the new file can automatically
  be set on the entity as its profile image. This is off by default
  (the entity profile image is not modified) but can be controlled
  with this parameter.
  """
  profileUpdateMode: SetEntityProfileImage = none
}

input CreateEntityIdentifierType {
  label: String!
  labelPlural: String!
  iconClass: String
  description: String
  dataType: EntityIdentifierDataType!
  id: ID!
}

input CreateEntityType {
  name: String!
  namePlural: String!
  schema: JSON!
}

input CreateEvent {
  """Name of the event to be created"""
  eventName: String!

  """The type of event"""
  eventType: String!

  """
  Identifier of the app using the event. Using "system" as application will throw error
  """
  application: String!

  """Event visibility. Private event is only visible to the app publisher."""
  public: Boolean! = false

  """General description of the event"""
  description: String

  """
  Optional schema. Accept on Protocol buffer format. If not provided,
  Custom message schema is inferred
  """
  schemaData: String
}

type CreateExecutionLocation {
  clusterId: ID!
  nodeId: ID
}

input CreateExportRequest {
  """
  Whether or not to include TDO media assets in the export.
  Setting this option can greatly increase the size of the export file.
  """
  includeMedia: Boolean = false

  """Information on the TDOs to export data from"""
  tdoData: [CreateExportRequestForTDO!]!

  """Information on the export output configuration"""
  outputConfigurations: [CreateExportRequestOutputConfig!] = []
}

input CreateExportRequestFormatConfig {
  """
  The file extension of the export type, such as "vlf" or "ttml".
  Must be supported by the requested engine category.
  """
  extension: String!

  """Optional export options specific to the target engine category."""
  options: JSON
}

input CreateExportRequestForTDO {
  """
  ID of the TDO to export from
  Either this option _or_ mentionId must be provided.
  This option must be provided if includeMedia is set to true on CreateExportRequest
  """
  tdoId: ID

  """
  ID of the mention to export from
  Either this option _or_ tdoId must be provided.
  """
  mentionId: ID

  """
  optional start offset in milliseconds for the export, relative to TDO startDateTime
  """
  startOffsetMs: Int

  """
  optional stop offset in milliseconds for the export, relative to the TDO stopDateTime.
  """
  stopOffsetMs: Int

  """
  optional start date for the exported results. Takes priority over startOffsetMs.
  """
  startDate: DateTime

  """
  optional end date for the exported results. Takes priority over stopOffsetMs.
  """
  stopDate: DateTime
}

input CreateExportRequestOutputConfig {
  """
  ID of an individual engine to export results for.
  Either this option _or_ categoryId must be provided.
  """
  engineId: ID

  """
  ID of an engine category to export results for.
  Either this option _or_ engineId must be provided.
  """
  categoryId: ID

  """Export output format configuration"""
  formats: [CreateExportRequestFormatConfig!]!
}

input CreateExternalCredential {
  sourceTypeId: ID
  dataId: ID
}

"""
Information required to create a new folder.
After creation, a folder can be renamed with the `updateFolder` mutation,
but no other changes are supported.
"""
input CreateFolder {
  """The folder name"""
  name: String!

  """The folder description"""
  description: String!

  """
  ID of the parent folder underneath which the new folder will be placed.
  """
  parentId: ID!

  """Root folder type to apply to the new folder"""
  rootFolderType: RootFolderType

  """
  Order index determining in what order the new folder will be displayed
  relative to other folders at the same level.
  """
  orderIndex: Int = 0
}

input CreateFolderContentTempate {
  """The ID of folder"""
  folderId: ID!

  """The ID of Structure Data Object"""
  sdoId: ID!

  """The ID of Data Registry"""
  schemaId: ID!
  data: JSON
}

input CreateIngestionConfiguration {
  applicationId: ID!
  type: String!
  name: String!

  """
  Container for arbitrary JSON-format metadata including configuration, etc.
  """
  jsondata: JSON

  """
  String containing raw JSON-format metadata. You can specify
  either this value or jsondata, but not both.
  """
  jsonstring: String
}

input CreateJob {
  status: String
  targetId: ID
  tasks: [CreateTask!]
  retries: Int = 0

  """
  Optionally, specify the scheduled job ID that this job is associated
  with. Typically it is not necessary for a client to set this; it is
  handled internally by the API.
  """
  scheduledJobId: ID

  """
  Supply a job template ID to indicate that this
  job was created from the given job template.
  To create a job _from_ a template, use `launchJobTemplates`.
  """
  jobTemplateId: ID
  skipDecider: Boolean

  """
  Optionally, specify a cluster ID where the job should run.
  Both the organization and the engine must have access to the cluster.
  """
  clusterId: ID

  """
  Optional job config information. Typically used only by Veritone
  platform components.
  """
  jobConfig: JSON
  isReprocessJob: Boolean
}

input CreateJobPipeline {
  jobTemplateIds: [ID!]
  isPublic: Boolean = false
}

input CreateJobTemplate {
  """The set of task template definitions for this job template."""
  taskTemplates: [CreateTaskTemplate!]

  """
  Optional. Specify a job pipeline ID if this job template is associated
  with a job pipeline.
  """
  jobPipelineId: ID

  """
  Optional. Should be set only if `jobPipelineId` is set.
  Specifies the stage in the pipeline at which this job template should
  be applied.
  """
  jobPipelineStage: Int

  """Used only by Veritone platform components."""
  skipDecider: Boolean

  """
  Optional job-level configuration. Typically used only by Veritone
  platform components.
  """
  jobConfig: JSON

  """
  Application ID. Used only by Veritone platform components.
  Other clients should not attempt to send this field. Any value sent
  will be ignored.
  """
  applicationId: ID
  clusterId: ID
}

input CreateLibrary {
  name: String!
  applicationId: ID
  organizationId: ID
  libraryTypeId: ID!
  coverImageUrl: String
  description: String
}

input CreateLibraryConfiguration {
  """ID of the selected library where this config appliess to"""
  libraryId: ID!

  """ID of the engine category this config applies to"""
  engineCategoryId: ID!

  """List of selected engines for training"""
  targetEngineIds: [ID]!

  """
  This option is used for Dataset Library Only
  List of selected engine where tdos are extracted from for training data
  TDOs are extracted from higher ranked engines first then fallback to the lower
  ones if the priors don't have any matching tdo
  """
  rankedSourceEngineIds: [ID]

  """
  This option is used for Dataset Library Only
  Dataset TDOs confidence filters
  """
  confidence: CreateDatasetConfidence
}

input CreateLibraryEngineModel {
  """ID of the engine the model is used by"""
  engineId: ID!

  """ID fo the library containing this engine model."""
  libraryId: ID!

  """Id of the train job."""
  trainJobId: ID
  trainStatus: LibraryEngineModelTrainStatus = pending

  """
  The URL to a file containing or related to the engine model.
  Use this field if the data is stored in a separate, internet-accessible
  location and not managed by Veritone APIs.
  You may also use `updateLibraryEngineModel` to upload a data file.
  """
  dataUrl: String

  """Optional free-form block containing engine-specific metadata."""
  jsondata: JSON
  accuracy: Int
  configurationId: ID
}

input CreateLibraryType {
  id: ID!
  label: String!
  iconClass: String
  entityIdentifierTypeIds: [ID!]
  entityType: CreateEntityType!
}

input CreateMediaShare {
  mediaType: String!

  """sourceId OR tdoId is required"""
  sourceId: ID
  tdoId: ID
  scheduledJobId: ID
  startDateTime: DateTime
  stopDateTime: DateTime
  startOffsetMs: Int
  stopOffsetMs: Int
  expireDateTime: DateTime

  """
  various settings for diffrent types of media. like audio only for videos
  """
  settings: JSON
}

input CreateMention {
  mediaId: ID!
  programId: ID!
  mentionDateTime: DateTime!
  mentionHitCount: Int!
  mentionStatusId: Int
  watchlistId: ID
  cognitiveEngineResultsString: String
  cognitiveEngineResults: JSON
  snippetsString: String
  snippets: JSON
  hitStartDateTime: DateTime
  hitEndDateTime: DateTime
  mentionEndDateTime: DateTime
  metadata: JSON
  queryTerm: String
}

input CreateMentionComment {
  mentionId: ID!
  commentText: String!
}

input CreateMentionExportRequest {
  """Filter information will be received to export data from"""
  mentionFilters: CreateMentionExportRequestFilter!

  """User local timezone"""
  userTimeZone: String = "America/Los_Angeles"
}

input CreateMentionExportRequestFilter {
  """List optional programIds will be filtered to export data"""
  programIds: [ID]

  """List optional marketIds will be filtered to export data"""
  marketIds: [ID]

  """List optional sourceIds will be filtered to export data"""
  mediaSourceIds: [ID]

  """List optional sourceTypeIds will be filtered to export data"""
  mediaSourceTypeIds: [ID]

  """List optional mentionStatusIds will be filtered to export data"""
  statusIds: [ID]

  """List optional spotTypeIds will be filtered to export data"""
  spotTypeList: [ID]

  """Filter mentionDate from/to"""
  date: CreateMentionExportRequestFilterDate

  """List optional watchlistIds will be filtered to export data"""
  watchlistIds: [ID]
}

input CreateMentionExportRequestFilterDate {
  from: DateTime
  to: DateTime
}

input CreateMentionRating {
  mentionId: ID!
  ratingValue: Int!
}

input CreateMentions {
  mentions: [CreateMention!]
}

input CreateMetrics {
  cpuCount: Int!
  mbRam: Int!
  mbDisk: Int!
  ipExternal: String
  ipInternal: String
  ami: String
  ec2InstanceType: String
  ec2Region: String
  awsAccount: String
  loadAverage: JSON
}

input CreateNextPipelineJobs {
  jobPipelineId: ID
  parentJobId: ID
  payload: JSON
  targetInfo: CreateNextPipelineJobsTargetInfo

  """
  Supply this value if and only if the job pipeline
  was started as part of a scheduled job.
  """
  scheduledJobId: ID
  organizationId: ID
  applicationId: ID
}

input CreateNextPipelineJobsTargetInfo {
  """
  ID of the target object for the job pipeline,
  typically that of a TemporalDataObject
  """
  targetId: ID!
  startOffsetMs: Int
  endOffsetMs: Int
}

input CreateOrganization {
  name: String!
  applications: JSON

  """Metadata in JSON format."""
  metadata: JSON!
  adminSeatLimit: Int
  seatLimit: Int
  status: OrganizationStatus = active
  maxAiwareNodes: Int
  maxAiwareClusters: Int
  businessUnit: String!
  integrations: JSON
  types: [OrganizationType]
}

input CreatePasswordResetRequest {
  """Optionally specify whether we should skip sending the reset email."""
  skipPasswordResetEmail: Boolean

  """The user login name. Typically email address."""
  userName: String!
}

type CreatePasswordResetRequestPayload {
  message: String
}

input CreatePasswordUpdateRequest {
  """The user's ID"""
  id: ID!

  """Optionally specify whether we should skip sending the reset email."""
  skipPasswordResetEmail: Boolean
}

input CreateProcessTemplate {
  name: String!
  taskList: JSON!
}

input CreateProgramAffiliate {
  sourceId: ID!
  scheduledDay: DayOfWeek!
  startDateTime: DateTime!
  stopDateTime: DateTime!
  startTime: Time!
  stopTime: Time!
}

input CreateRecurringSchedulePart {
  repeatIntervalUnit: IntervalUnit!
  repeatInterval: Int!
  durationSeconds: Int

  """Time of day, required for repeat interval unit in days."""
  startTime: Time
}

input CreateSavedSearch {
  name: String!
  sharedWithOrganization: Boolean = false
  csp: JSON!
}

input CreateScheduledJob {
  jobPipelineIds: [ID!]
  jobTemplateIds: [ID!]
  jobTemplates: [CreateJobTemplate!]
  weeklyScheduleParts: [CreateWeeklySchedulePart!]
  recurringScheduleParts: [CreateRecurringSchedulePart!]
  name: String!

  """A detailed description. Defaults to name."""
  description: String
  runMode: RunMode = Once

  """
  JSON containing metadata details for this scheduled job.
  If supplied, then the detailsSchemaId must also be set.
  The supplied data must comply with the schema
  """
  details: JSON

  """Schema ID for detail metadata on this scheduled job"""
  detailsSchemaId: ID
  isActive: Boolean = true
  startDateTime: DateTime
  stopDateTime: DateTime

  """Optionally, associate content templates with the new scheduled job"""
  contentTemplates: [CreateScheduledJobContentTemplateWithScheduledJob!]

  """
  Organization ID. Used only by Veritone platform components.
  Other clients should not attempt to send this field. Any value sent
  will be ignored.
  """
  organizationId: ID

  """
  Indicates whether or not the scheduled job is publicly accessible.
  Only Veritone administrators can create public scheduled jobs.
  Other users will get an error if they attempt to set this value to true.
  """
  isPublic: Boolean = false
  affiliates: [CreateProgramAffiliate!]
}

input CreateScheduledJobCollaborator {
  """ID of the organization to share the source with"""
  organizationId: ID!

  """
  Permission to grant. Can be `editor` or `viewer`.
  Set to `none` to revoke permissions for this organization.
  """
  permission: SetScheduledJobPermission!
}

input CreateScheduledJobContentTemplate {
  """Specify the scheduled job ID that this content template applies to"""
  scheduledJobId: ID!

  """
  Supply the ID of the data registry that contains the schema
  for the content template.
  """
  schemaId: ID!

  """
  To associate an existing structured data object (SDO) to the
  source, provide the SDO ID. Either this field or data must be supplied.
  """
  sdoId: ID

  """
  To create a new structured data object, supply this field with
  JSON to save in the SDO. The JSON must comply with the schema
  defined in data registry.
  """
  data: JSON
}

input CreateScheduledJobContentTemplateWithScheduledJob {
  """
  Supply the ID of the data registry that contains the schema
  for the content template.
  """
  schemaId: ID!

  """
  To associate an existing structured data object (SDO) to the
  source, provide the SDO ID. Either this field or data must be supplied.
  """
  sdoId: ID

  """
  To create a new structured data object, supply this field with
  JSON to save in the SDO. The JSON must comply with the schema
  defined in data registry.
  """
  data: JSON
}

"""Data used to create a new source"""
input CreateSource {
  """The source type ID"""
  sourceTypeId: ID!

  """
  The human-readable source name. The value does not have to be unique,
  but it is strongly recommended to use a name that is unique within
  the owning organization.
  """
  name: String!

  """
  Indicates whether or not the source is public. Default is false (private
  to owner organization).
  """
  isPublic: Boolean = false

  """
  Additional metadata to associate with the source. This data may be
  validated against a schema associated with the source type.
  """
  details: JSON

  """Optional thumbnail image URL for the source"""
  thumbnailUrl: String

  """Optionally, associate content templates with the new source"""
  contentTemplates: [CreateSourceContentTemplateWithSource!]

  """
  Optionally associate a schema for correlation.
  Required when correlationSDOId is specified.
  """
  correlationSchemaId: ID

  """
  Optionally associate a structured data object of the specified correlationSchemaId.
  Required when correlationSchemaId is specified.
  """
  correlationSDOId: ID

  """Add or modify collaborators on the source."""
  collaborators: [CreateSourceCollaborator!]

  """
  Optionally, set an initial state for the source.
  This is typically not required.
  """
  state: JSON
}

input CreateSourceCollaborator {
  """ID of the organization to share the source with"""
  organizationId: ID!

  """
  Permission to grant. Can be `editor` or `viewer`.
  Set to `none` to revoke permissions for this organization.
  """
  permission: SetSourcePermission!
}

input CreateSourceContentTemplate {
  """Specify the source ID that this content template applies to"""
  sourceId: ID!

  """
  Supply the ID of the data registry that contains the schema
  for the content template.
  """
  schemaId: ID!

  """
  To associate an existing structured data object (SDO) to the
  source, provide the SDO ID. Either this field or data must be supplied.
  """
  sdoId: ID

  """
  To create a new structured data object, supply this field with
  JSON to save in the SDO. The JSON must comply with the schema
  defined in data registry.
  """
  data: JSON
}

input CreateSourceContentTemplateWithSource {
  """
  Supply the ID of the data registry that contains the schema
  for the content template.
  """
  schemaId: ID!

  """
  To associate an existing structured data object (SDO) to the
  source, provide the SDO ID. Either this field or data must be supplied.
  """
  sdoId: ID

  """
  To create a new structured data object, supply this field with
  JSON to save in the SDO. The JSON must comply with the schema
  defined in data registry.
  """
  data: JSON
}

input CreateSourceType {
  sourceSchemaId: ID
  credentialSchemaId: ID
  name: String!
  details: JSON
  credentialType: CredentialType = None

  """
  Indicates that the source type is publicly accessible.
  If false, is usable only by the owner organization.
  """
  isPublic: Boolean

  """
  Indicates whether or not the source type is "live", such
  as a camera feed
  """
  isLive: Boolean

  """
  Indicates whether or not the source type requires
  scan pipeline jobs
  """
  requiresScanPipeline: Boolean = false

  """Source type category ID"""
  categoryId: ID!
}

input CreateStructuredData {
  """Optionally provide a forced ID"""
  id: ID

  """Id of the schema used to validate this object"""
  schemaId: ID!
  data: JSON
  dataString: String
}

input CreateSubscription {
  """ID of the object (probably a watchlist) to create a subscription for"""
  targetId: ID!
  objectType: SubscriptionObjectType = mention
  contact: CreateSubscriptionContact!
  frequency: SubscriptionFrequency = daily
  scheduledDay: DayOfWeek
  scheduledTime: Time
  scheduledTimeZone: String = "GMT"
}

input CreateSubscriptionContact {
  emailAddress: String
  phoneNumber: String
  webhookUri: String
}

"""
Used to create a subscription while creating a watchlist.
The subscription will be for the new watchlist.
"""
input CreateSubscriptionInWatchlist {
  objectType: SubscriptionObjectType = mention
  contact: CreateSubscriptionContact!
  frequency: SubscriptionFrequency = daily
  scheduledDay: DayOfWeek
  scheduledTime: Time
  scheduledTimeZone: String = "GMT"
}

"""Fields required to create a task. Used when creating a job."""
input CreateTask {
  """
  The task type, which is mapped on the server to an engine ID.
  Either taskType OR engineId is required.
  """
  taskType: String

  """
  Engine ID to be used for the task.
  Either engineId OR taskType is required.
  """
  engineId: ID

  """
  Task payload in raw string form.
  Optional. Only one of payloadString and payload is permitted.
  """
  payloadString: String

  """
  Task payload in GraphQL format.
  Optional. Only one of payloadString and payload is permitted.
  """
  payload: JSON

  """Optional. Specifies whether or not the task target should be cloned."""
  isClone: Boolean

  """Optional. Specifies the build ID of the engine"""
  buildId: String

  """Optional. Specifies whether the task is for testing."""
  testTask: Boolean

  """
  Optionally, provide a task definition that will be executed if
  and only if this one fails. Standby tasks can be nested.
  """
  standbyTask: CreateTask
}

input CreateTaskLog {
  """ID of the task which the task long belongs to."""
  taskId: ID!

  """A file to upload. Use multipart form POST to submit this field."""
  file: UploadedFile
}

input CreateTaskTemplate {
  engineId: ID
  engineConfigId: ID
  executionLocationId: ID
  jobTemplateId: ID
  payload: JSON
  payloadString: String
  parentTaskId: ID
}

"""Payload required to create a temporal data object"""
input CreateTDO {
  """Start date and time in numerical (epoch) format."""
  startDateTime: DateTime!

  """Stop date and time in numerical (epoch) format."""
  stopDateTime: DateTime!

  """Source for the TDO, such as an ingestion type or engine ID."""
  source: String

  """
  Status, such as "downloaded" or "recording".
  The server will set a value if one is not provided.
  """
  status: String = "downloaded"

  """
  A name for the TDO object, such as the name of the primary media file.
  """
  name: String

  """A description for the TDO object."""
  description: String

  """
  True if the new TDO should be made public. If true, security.global
  will be set to true and users from other organizations will be able to
  view, but not modify, the TDO's metadata and assets.
  """
  isPublic: Boolean

  """
  An optional parent folder ID for the new TemporalDataObject.
  The folder can be filed in additional folders later using `fileTemporalDataObject`,
  or un-filed from this one.
  """
  parentFolderId: ID

  """
  Optionally, set source data for this TDO. Source data identifies
  that task that generated this TDO. If the TDO was not generated as part
  of engine or adapter execution, this field should not be set.
  However, it is _strongly_ recommended that engines that create TDOs
  set this field. Doing so ensures that later tasks in the same job
  have appropriate access to the new TDO.
  """
  sourceData: SetTDOSourceData
  details: JSON

  """Only internal systems can set this value"""
  applicationId: ID

  """
  Optionally, specify one or more structured data objects to apply as
  content templates to the TDO. They will be stored as assets of type
  content-template and will contain an immutable copy of the original data.
  """
  contentTemplates: [CreateTDOContentTemplateWithTDO!]

  """
  Optionally, add the new data to the search index. If the data is not
  indexed on creation, it can be indexed later by using `updateTDO` or
  creating a suitable job.
  """
  addToIndex: Boolean = false

  """An optional thumbnail URL for the TDO"""
  thumbnailUrl: String

  """An optional preview asset URL for the TDO"""
  previewUrl: String

  """An optional image representing the TDO source"""
  sourceImageUrl: String
}

input CreateTDOContentTemplateWithTDO {
  """
  Supply the ID of the data registry that contains the schema
  for the content template.
  """
  schemaId: ID!

  """
  To associate an existing structured data object (SDO) to the
  TDO, provide the SDO ID. Either this field or data must be supplied.
  """
  sdoId: ID

  """
  To create a new structured data object, supply this field with
  JSON to save in the SDO. The JSON must comply with the schema
  defined in data registry.
  """
  data: JSON
}

input CreateTDOForJob {
  """
  A name for the TDO object, such as the name of the primary media file.
  If not provided, the TDO will have the name of the scheduled job that
  created it.
  """
  name: String

  """A description for the TDO object."""
  description: String

  """
  True if the new TDO should be made public. If true, security.global
  will be set to true and users from other organizations will be able to
  view, but not modify, the TDO's metadata and assets.
  """
  isPublic: Boolean

  """
  An optional parent folder ID for the new TemporalDataObject.
  The folder can be filed in additional folders later using `fileTemporalDataObject`,
  or un-filed from this one.
  """
  parentFolderId: ID

  """Only internal systems can set this value"""
  applicationId: ID

  """
  Status, such as "downloaded" or "recording".
  The server will set a value if one is not provided.
  """
  status: String

  """Detailed metadata about the TDO"""
  details: JSON

  """
  Optionally, specify one or more structured data objects to apply as
  content templates to the TDO. They will be stored as assets of type
  content-template and will contain an immutable copy of the original data.
  """
  contentTemplates: [CreateTDOContentTemplateWithTDO!]

  """
  Optionally, add the new data to the search index. If the data is not
  indexed on creation, it can be indexed later by using `updateTDO` or
  creating a suitable job.
  """
  addToIndex: Boolean = false

  """An optional thumbnail URL for the TDO"""
  thumbnailUrl: String

  """An optional preview asset URL for the TDO"""
  previewUrl: String

  """An optional image representing the TDO source"""
  sourceImageUrl: String
}

input CreateTDOWithAsset {
  """TDO status, such as "recorded" (the default)"""
  status: String = "recorded"

  """
  A name for the TDO object, such as the name of the primary media file.
  """
  name: String

  """Start date and time for the file"""
  startDateTime: DateTime!

  """
  Stop date and time. If not passed, the server
  will apply a value based on the default
  chunk size of 15 minutes.
  """
  stopDateTime: DateTime

  """determine stopDateTime based on the length of the media asset"""
  updateStopDateTimeFromAsset: Boolean = false

  """The ingestion source ID for this file"""
  sourceId: ID

  """
  Content type for the file.
  Default is "video/mp4"
  """
  contentType: String = "video/mp4"

  """The file location or URI."""
  uri: String
  file: UploadedFile

  """Deprecated - use scheduledJobId"""
  scheduleId: ID

  """The scheduled job ID."""
  scheduledJobId: ID

  """
  True if the new TDO should be made public. If true, security.global
  will be set to true and users from other organizations will be able to
  view, but not modify, the TDO's metadata and assets.
  """
  isPublic: Boolean

  """
  An optional parent folder ID for the new TemporalDataObject.
  The folder can be filed in additional folders later using `fileTemporalDataObject`,
  or un-filed from this one.
  """
  parentFolderId: ID

  """Asset type. Default is "media"."""
  assetType: String = "media"

  """
  Optionally, set source data for this TDO. Source data identifies
  that task that generated this TDO. If the TDO was not generated as part
  of engine or adapter execution, this field should not be set.
  However, it is _strongly_ recommended that engines that create TDOs
  set this field. Doing so ensures that later tasks in the same job
  have appropriate access to the new TDO.
  This source data will be set on both the TDO and the asset.
  """
  sourceData: SetTDOSourceData
  details: JSON

  """
  Optionally, specify one or more structured data objects to apply as
  content templates to the TDO. They will be stored as assets of type
  content-template and will contain an immutable copy of the original data.
  """
  contentTemplates: [CreateTDOContentTemplateWithTDO!]

  """
  Optionally, add the new data to the search index. If the data is not
  indexed on creation, it can be indexed later by using `updateTDO` or
  creating a suitable job.
  """
  addToIndex: Boolean = false

  """An optional thumbnail URL for the TDO"""
  thumbnailUrl: String

  """An optional preview asset URL for the TDO"""
  previewUrl: String

  """An optional image representing the TDO source"""
  sourceImageUrl: String
}

input CreateTriggers {
  """ List of events in csv form. Use "*" to listen to all events. When using a wild card, csv form is no longer valid.
   Either events or types can be specified at a time. Example:
  
   events: "event1,event2,event3" // valid
  
   events: "*" // valid
  
   events: "*,event1" // invalid
  """
  events: String

  """ List of events in csv form. Use "*" to listen to all types. When using a wild card, csv form is no longer valid.
   Either events or types can be specified at a time. Example:
  
   types: "type1,type2,type3" // valid
  
   types: "*" // valid
  
   types: "*,type1" // invalid
  """
  types: String

  """Array of hook targets"""
  targets: [CreateTriggerType]
}

enum CreateTriggerTarget {
  """ Webhook target should provide the following kvp in the json structure of
   TargetType:params
  
   "url":"<protocol>://<your_url>"
  """
  Webhook

  """ SMS target should provide the following kvp in the json structure of
   TargetType:params
  
   "number": ########
  """
  SMS

  """ Email target should provide the following kvp in the json structure of
   TargetType:params
  
   "address":"<your_address>@<your_domain>"
  """
  Email
}

input CreateTriggerType {
  """
  The name of the trigger target. Currently we only support
  Webhook, SMS, and Email
  """
  name: CreateTriggerTarget!

  """
  The parameters for this hook. Must be a JSON payload. See
  HookTarget docs for supported kvp for each HookTarget type.
  """
  params: JSON!
}

input CreateUser {
  name: String!

  """
  Metadata in JSON format. If a field is provided elsewhere in the
  payload, it does not need to be saved in jsondata.
  """
  jsondata: JSON

  """User who requested that the new user be provisioned"""
  requestorId: ID

  """
  Password for new user. Optional - if not provided, the user will
  need to set on first login.
  """
  password: String
  organizationId: ID!
  sendNewUserEmail: Boolean
  email: String
  roleIds: [ID!]
  acls: [UserACLInput!]

  """Optionally, specify user's first name"""
  firstName: String

  """Optionally, specify user's last name"""
  lastName: String
}

input CreateWatchlist {
  """
  Date and time at which the watchlist becomes effective.
  If not provided, defaults to current time.
  """
  startDateTime: DateTime

  """
  Date and time at which the watchlist expires and is no longer effective.
  """
  stopDateTime: DateTime!
  cognitiveSearches: [CreateCognitiveSearchInWatchlist!]
  name: String!
  sourceTypeIds: [ID!]

  """Optional ID for a folder the watchlist should be filed in"""
  parentFolderId: ID
  sourceIds: [ID!]

  """
  Set structured metadata on the watchlist.
  The data is subject to a set of schemas.
  """
  details: JSON
  searchIndex: SearchIndex = global
  subscriptions: [CreateSubscriptionInWatchlist!]
}

input CreateWeeklySchedulePart {
  scheduledDay: DayOfWeek
  startTime: Time
  stopTime: Time
}

input CreateWidget {
  collectionId: ID!
  folderId: String
  name: String
  adScript: String = ""
  width: Int = 600
  numberOfMentionsToShow: Int = 10
  displayLogo: Boolean = false
  displayCollectionName: Boolean = false
  displayMentionIntro: Boolean = false
  displayTranscription: Boolean = false
  displayCollectionDescription: Boolean = false
  displayMentionDescription: Boolean = false
  seoTags: [String] = []
  backgroundColor: String = "FFFFFF"
  borderColor: String = "D8D8D8"
  textColor: String = "000000"
  nextButtonColor: String
}

input CreateWorkflowRuntimeStorageData {
  """Unique lookup id for the workflowRuntimeData"""
  storageKey: String!

  """Data content - base64 encoded binary, plain string or encoded JSON"""
  storageData: String!

  """Optional metadata for the workflowRuntimeData"""
  storageMetadata: String
}

type Creative {
  id: ID!
  name: String!
  keywords: String
  organizationId: ID!
  advertiserId: ID
  brandId: ID
}

enum CredentialType {
  None
  Any
  APIKey
  Username
}

"""Analytics Dashboards"""
type Dashboard {
  """The order in which to display the dashboard."""
  index: Int
  title: String
  description: String

  """The status of the dashboard"""
  active: Boolean

  """
  The filters that can be applied on the dashboard. Typically watchlists.
  """
  filters: [String]
  type: String

  """Vendor specific identifier for Qlik applications"""
  qlikAppId: String

  """Vendor specific identifier for Qlik sheet"""
  qlikSheetId: String
  thumbnail: String
}

type DataRegistry {
  id: ID!
  name: String
  description: String
  source: String
  schemas(status: [SchemaStatus], majorVersion: Int, id: ID, offset: Int = 0, limit: Int = 30, orderBy: [SchemaOrder]): SchemaList

  """The organization that owns this data registry."""
  organization: Organization
  organizationId: ID
  createdBy: User
  modifiedBy: User
  createdDateTime: DateTime
  modifiedDateTime: DateTime

  """
  The currently published schema version for convenient access.
  This field will be empty if there is no published schema.
  """
  publishedSchema: Schema
  ingestionToken: String
}

type DataRegistryList implements Page {
  records: [DataRegistry]

  """The starting index for records that were returned in this query."""
  offset: Int!

  """
  Maximum number of results that were retrieved in this query; page size
  """
  limit: Int!

  """Number of records returned in this response"""
  count: Int
}

enum DataRegistryOrderBy {
  name
  source
  createdDateTime
  modifiedDateTime
}

input DataRegistryVersion {
  """The id of the DataRegistry"""
  id: ID!

  """The major version of the DataRegistry"""
  majorVersion: Int! = 1
}

type DatasetConfidence {
  """
  Mininum Confidence Filter. Sources with confidence lower than this will be ignore
  """
  min: Float

  """
  Maximum Confidence Filter. Sources with confidence higher than this will be ignore
  """
  max: Float

  """allow sources with null confidence values"""
  allowNull: Boolean
}

"""Date/time custom scalar type"""
scalar DateTime

enum DayOfWeek {
  Sunday
  Monday
  Tuesday
  Wednesday
  Thursday
  Friday
  Saturday
}

input DeleteBuild {
  id: ID!
  engineId: ID!
}

"""Delete a folder"""
input DeleteFolder {
  """ID of the folder to delete"""
  id: ID!
  orderIndex: Int!
}

input DeleteLibraryDataset {
  """Id of the selected library"""
  libraryId: ID!

  """List of tdo ids to remove to the selected library"""
  tdoIds: [ID]!
}

type DeleteLibraryDatasetPayload {
  """Id of the selected library"""
  libraryId: ID

  """List of tdos removed from dataset library"""
  tdoIds: [ID]

  """Delete status"""
  message: String
}

input DeleteMentionComment {
  mentionId: ID!
  commentId: ID!
}

"""
Input required to delete a mention rating.
Both the rating and mention IDs must be provided.
Only the rating will be deleted.
"""
input DeleteMentionRating {
  """The mention ID"""
  mentionId: ID!

  """The rating ID"""
  ratingId: ID!
}

"""Payload required to delete an object"""
type DeletePayload {
  """ID of the object that was deleted"""
  id: ID!

  """a message"""
  message: String
}

input DeleteStructuredData {
  id: ID!

  """Id of the schema used to validate this object"""
  schemaId: ID!
}

"""
Deployment models describe how an engine or application operates on the network
and where the data it works with is transmitted. See Veritone's developer
documentation at https://steel-ventures.atlassian.net/wiki/spaces/VDH/pages/101364981/Engine+Deployment+Models
for a full description.
"""
enum DeploymentModel {
  """
  The engine or application is fully isolated and does not call out to any
  external endpoints. Numerical code 0.
  """
  FullyNetworkIsolated

  """
  The engine or application does not transmit data about its payload over the internet,
  but may still make external network calls for limited purposes. Numerical code 1.
  """
  MostlyNetworkIsolated

  """
  The engine or application is not network isolated and must call out to external services
  and transmit data about its payload. Numerical code 2.
  """
  NonNetworkIsolated

  """Human review of engine results is required. Numerical code 3."""
  HumanReview
}

input EmitEvent {
  """Event name"""
  eventName: String!

  """Existing event type"""
  eventType: String!

  """Identifier of the app using the event"""
  application: String!

  """
  string payload, it should be serialized Protobuf data with base64 encoding or escaped JSON string
  """
  payload: String!
}

type EmitEventResponse {
  id: ID!

  """the decoder that GQL used to interpret your event before sending"""
  decoder: String!
}

input EmitSystemEvent {
  """A topic"""
  topic: String!

  """The event payload"""
  payload: JSON!
}

type Engine {
  id: ID!
  ownerOrganizationId: ID!
  isPublic: Boolean
  logoPath: String
  iconPath: String

  """
  The signed URL for the engine icon; will fallback to raw iconPath if unable to sign.
  """
  signedIconPath: String

  """
  The signed URL for the engine logo; will fallback to raw logoPath if unable to sign.
  """
  signedLogoPath: String
  name: String
  ownerOrganization: Organization
  description: String
  categoryId: String
  state: EngineState
  price: Int
  asset: String
  displayName: String
  validateUri: String
  executeUri: String
  applicationId: ID

  """
  True if the engine creates a TemporalDataObject (TDO) as part of its
  execution. False otherwise.
  """
  createsTDO: Boolean
  website: String
  rating: Int
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  createdBy: String
  modifiedBy: String

  """
  True if the engine requires a library to run. If so, a library ID must
  be provided in the engine payload.
  """
  libraryRequired: Boolean
  deploymentModel: DeploymentModel
  tasks(
    status: [String]

    """
    Provide an offset to skip to a certain element in the result, for paging.
    """
    offset: Int = 0

    """
    Specify maximum number of results to retrieve in this result. Page size.
    """
    limit: Int = 30
    id: ID

    """
    Filter the tasks by date/time field.
    If a filter is not provided, a default of `createdDateTime` between
    three months ago and the current date will be applied.
    """
    dateTimeFilter: [TaskDateTimeFilter]
    hasSourceAsset: Boolean
  ): TaskList

  """
  Retrieve builds for the engine.
  By default, deleted builds are not included.
  Deleted builds can be retrieved by including the `deleted` status parameter.
  """
  builds(
    buildStatus: [BuildStatus!]
    status: [String]

    """
    Provide an offset to skip to a certain element in the result, for paging.
    """
    offset: Int = 0

    """
    Specify maximum number of results to retrieve in this result. Page size.
    """
    limit: Int = 30
    id: ID
  ): BuildList

  """Dependency information for this engine"""
  dependency: EngineDependency

  """
  The list of custom fields on the engine. Users will be prompted to
  set or change these values when they run the engine. For example, a
  translation engine might have a field for the target language.
  """
  fields: [EngineField!]

  """The engine category"""
  category: EngineCategory
  validStateActions: [EngineStateAction]

  """
  Get the engine's preferred input format, based on the latest deployed build.
  If there is no deployed build this field cannot be populated.
  """
  preferredInputFormat: String

  """
  Get the engine's supported input formats, based on the latest deployed build.
  If there is no deployed build this field cannot be populated.
  """
  supportedInputFormats: [String!]

  """
  Get the engine's output formats, based on the latest deployed build.
  If there is no deployed build this field cannot be populated.
  """
  outputFormats: [String!]

  """
  List of IDs of source types that the engine supports,
  based on the latest deployed build.
  If there is no deployed build this field cannot be populated.
  Applies only to adapter engines that ingest data from a source.
  Will be a list of IDs of SourceType objects.
  """
  supportedSourceTypes: [String!]

  """
  Get the ingestion flag which determines whether the adapter has a scan phase during ingestion.
  If there is no deployed build this field cannot be populated.
  """
  hasScanPhase: Boolean

  """
  Get the deployed build version of this engine. If there is no deployed
  build, this field will be null.
  """
  deployedVersion: Int

  """Specifies the mode in which the engine process input"""
  mode: EngineMode

  """
  Specifies the runtime type, such as "iron" or "edge"
  """
  runtimeType: String

  """
  Get oauth information based on the deployed build. If there is no deployed
  build, this field will be null.
  """
  oauth: String

  """
  Get engine flag which determines whether the engine is a conductor,
  this field will be null
  """
  isConductor: Boolean

  """
  List of schedule types that the engine supports,
  based on the latest deployed build.
  If there is no deployed build, this field cannot be populated.
  """
  supportedScheduleTypes: [EngineScheduleType!]

  """Retrieve task metrics for the engine"""
  taskMetrics(
    """Provide a starting date in ISO format (maximum range of 7 days)"""
    fromDateTime: DateTime

    """Provide an end date in ISO format (maximum range of 7 days)"""
    toDateTime: DateTime
  ): EngineTaskMetrics
}

type EngineBlacklist {
  organizationId: ID!
  engines: [Engine]
  engineCategories: [EngineCategory]
}

type EngineCategory {
  id: ID!
  name: String
  description: String
  type: EngineType
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  createdBy: String
  modifiedBy: String

  """The list of IDs of engines in this category"""
  engineIds: [ID!]
  totalEngines: Int
  iconClass: String
  editable: Boolean
  videoOnly: Boolean
  color: String

  """The list of engines in this category"""
  engines(
    offset: Int = 0
    limit: Int = 30

    """Filters for engine attributes"""
    filter: EngineFilter

    """Provide a list of EngineSortField to sort by."""
    orderBy: [EngineSortField]
  ): EngineList

  """
  If the engine category is integrated with libraries, this field contains
  the list of IDs of entity identifier types that the engine category is compatible
  with.
  """
  libraryEntityIdentifierTypeIds: [ID!]

  """
  If the engine category is integrated with libraries, this field contains
  the list of entity identifier types that the engine category is compatible
  with.
  """
  libraryEntityIdentifierTypes: EntityIdentifierTypeList

  """
  A type for the engine category. Multiple engine categories with common
  elements can share a categoryType. This information is used to compute
  dependencies and format user interface elements.
  """
  categoryType: String

  """
  An optional key used to identify this engine category's results for
  search and other purposes.
  Primarily used by Veritone platform applications.
  """
  categoryMetadataKey: String

  """
  A list of categoryTypes on which instances of this engine category depend.
  """
  dependencies: [EngineDependency!]

  """
  Information about how engine results in this category can be searched
  in Veritone platform applications.
  Used primarily by Veritone platform applications.
  """
  searchConfiguration: EngineSearchConfiguration

  """
  List of engine result export formats supported by engines in this
  category. May be empty.
  """
  exportFormats: [ExportFormat]!
}

type EngineCategoryList implements Page {
  records: [EngineCategory!]
  offset: Int!
  limit: Int!
  count: Int
}

type EngineConfiguration {
  id: ID!
  credentials: [ExternalCredential!]
  sourceId: ID
  source: Source
}

type EngineConfigurationList implements Page {
  records: [EngineConfiguration!]!
  count: Int!
  offset: Int!
  limit: Int!
}

type EngineDependency {
  """
  TODO maps to values in engineCategory.data_field?
  Must be a valid categoryType from an existing EngineCategory.
  """
  dependencyType: String!

  """Asset type to expect previous engine to produce"""
  assetType: String

  """The engine category corresponding to this dependency"""
  category: EngineCategory
}

"""Represents a custom input field on an engine."""
type EngineField {
  """
  Maximum value, in float format. Applies only to fields of type Number.
  """
  max: Float

  """
  Minimum value, in float format. Applies only to fields of type Number.
  """
  min: Float

  """
  Numerical step by which the value should be incremented or decremented in
  the user interface, in float format. Applies only to fields of type Number.
  """
  step: Float

  """The field type."""
  type: EngineFieldType!

  """General information about the field, such as a description."""
  info: String

  """A machine-readable name, or key, for the field."""
  name: String!

  """A human-readable label for the field."""
  label: String

  """
  A set of allowed values for the field. Applies only to fields of type
  picklist or multi-picklist.
  """
  options: [EngineFieldPicklistOption!]

  """
  An optional default value for the field. Taken in string format, but
  applies to all field types.
  """
  defaultValue: String

  """
  Optional default values to apply to a picklist. This field
  should only be set for a field of type multi-picklist.
  """
  defaultValues: [String!]
}

"""Represents one allowed option in a picklist."""
type EngineFieldPicklistOption {
  """
  The human-readable label for the option, such as "English-US" for a language selector.
  """
  key: String!

  """
  The machine-readable value that will be sent in the engine payload, such as
  "en-us" for a language selector.
  """
  value: String!
}

"""An enum containing valid custom engine field types."""
enum EngineFieldType {
  """A number, in float format"""
  Number

  """
  A pick list that allows the user to choose one of a set of allowed values.
  """
  Picklist

  """
  A pick list that allows the user to choose any number of a set of allowed values.
  """
  MultiPicklist

  """A plain text field"""
  Text

  """A dynamic list of schemas that will be populated by the client"""
  SchemaSelection
}

input EngineFilter {
  """Language supported by the engine"""
  language: String

  """provide a list of engine category names to filter by"""
  category: [String]

  """provide a list of engine type names to filter by"""
  type: [EngineTypeFilter!]

  """Provide a list of rating from 0 to 5 to filter by."""
  rating: [Int]

  """Specify the deployment model of the engine."""
  deploymentModel: DeploymentModel

  """Specify the minimum price of the engine."""
  priceMin: Int

  """Specify the maximum price of the engine."""
  priceMax: Int

  """Specify the minimum FedRamp impact level of the engine."""
  fedRampImpactLevelMin: Int

  """Specify the minimum FedRamp impact level of the engine."""
  fedRampImpactLevelMax: Int

  """Filter engines that can be trainable via API."""
  trainableViaApi: Boolean

  """Filter engines by cluster size."""
  clusterSize: ClusterSize

  """Filter engines by gpu supported."""
  gpuSupported: SupportedGPU

  """Provide a list of engine modes to filter by"""
  mode: [EngineMode!]

  """Provide a list of runtime types to filter by"""
  runtimeType: [String!]
}

"""Contain resouces of Engine JWT Token"""
type EngineJWTResource {
  applicationId: ID
  tdoId: ID
  jobId: ID!
  taskId: ID!
}

type EngineList implements Page {
  records: [Engine]

  """Number of records returned in this response"""
  count: Int!

  """The starting index for records that were returned in this query."""
  offset: Int!
  limit: Int!
}

enum EngineMode {
  Chunk
  Stream
  Batch
}

enum EngineOrderField {
  name
  id
  state
  price
  rating
  order
  createdDateTime
  modifiedDateTime
}

"""Represents single chunk of engine results for date range"""
type EngineResult {
  tdoId: ID!
  engineId: ID!
  jsondata: JSON
  startOffsetMs: Int
  stopOffsetMs: Int
  assetId: String
  userEdited: Boolean
  tdo: TemporalDataObject
}

"""Represents a collection of engine results. Not Paged."""
type EngineResultList {
  sourceId: ID
  records: [EngineResult]
}

"""Describes engine run on a TDO with"""
type EngineRun {
  """Engine that was run on a TDO"""
  engine: Engine

  """
  Engine status derived from the written engine output or task status. See TaskStatus enum for details.
  """
  status: TaskStatus

  """Last run task for this engine and tdo"""
  task: Task

  """Whether or not the engine run has user edits"""
  hasUserEdits: Boolean
}

type EngineRunList implements Page {
  records: [EngineRun]

  """The starting index for records that were returned in this query."""
  offset: Int!
  limit: Int!

  """Number of records returned in this response"""
  count: Int
}

enum EngineScheduleType {
  Now
  OnDemand
  Recurring
  Continuous
}

"""
Represents configuration on how the results of engines within a given
category are indexed and searched.
Primarily used by Veritone platform applications.
"""
type EngineSearchConfiguration {
  """
  Autocomplete field information is used to tell client applications
  what fields are searchable by autocomplete in the search index and
  how to search for them.
  """
  autocompleteFields: [AutocompleteFieldConfig!]

  """
  Autocomplete field information is used to tell client applications
  what fields are searchable in the search index and
  how to search for them.
  """
  searchFields: [SearchFieldConfig!]

  """
  Indicates whether or not search is available for results produced
  by engines in this category can be searched.
  """
  isSearchEnabled: Boolean

  """
  Indicates whether or not search is available for results produced
  by engines in this category can be searched within the Elasticsearch index.
  """
  isElasticEnabled: Boolean
  searchMetadataKey: String
  elasticType: String
}

input EngineSortField {
  field: EngineOrderField!
  direction: OrderDirection
}

"""
Enumeration containing the set of allowed values for the Engine state field.
"""
enum EngineState {
  """
  The engine is deployed and active. Set the state to this value to deploy it.
  """
  active

  """The engine has been disabled. Set this state to disable the engine."""
  disabled

  """
  The engine is awaiting approval before transitioning to the next state.
  """
  pending

  """The engine has been deleted and is no longer available for use."""
  deleted

  """
  The engine is in draft state, suitable for review and internal testing.
  """
  draft

  """The engine is ready for deployment, but has not been deployed yet."""
  ready
}

enum EngineStateAction {
  edit
  delete
  disable
  enable
  undelete
}

type EngineTaskMetrics {
  cancelledCount: Int
  completedCount: Int
  failedCount: Int
  pendingCount: Int
  queuedCount: Int
  runningCount: Int
}

type EngineType {
  name: String
  description: String
}

enum EngineTypeFilter {
  Cognition
  Ingestion
  Aggregator
}

type EngineWhitelist {
  organizationId: ID!
  engines: [Engine]
  engineCategories: [EngineCategory]
}

input EngineWorkflow {
  id: ID!
  action: EngineWorkflowAction!
}

enum EngineWorkflowAction {
  enable
  disable
}

type Entity {
  id: ID!
  name: String
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  createdBy: String
  modifiedBy: String
  properties: [Property]
  libraryId: ID
  library: Library
  profileImageUrl: String
  identifiers(
    """Provide an ID to retrieve a specific entity identifier"""
    id: ID
    identifierTypeId: ID
    offset: Int = 0
    limit: Int = 30
  ): EntityIdentifierList
  isPublished: Boolean
  jsondata: JSON
  jsonstring: String
  summary: EntitySummary
  description: String
}

type EntityIdentifier {
  id: ID!
  entityId: ID!
  entity: Entity!
  identifierType: EntityIdentifierType!
  identifierTypeId: ID!
  title: String
  isPriority: Boolean
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  url: String!
  contentType: String!
  jsondata: JSON
  jsonstring: String
}

enum EntityIdentifierDataType {
  image
  audio
  video
  text
  pdf
  tdo
}

type EntityIdentifierItem {
  libraryTypeId: String!
  entityIdentifierTypeId: String!
  minItems: Int
  maxItems: Int
}

type EntityIdentifierItemList {
  records: [EntityIdentifierItem]
  limit: Int!
  offset: Int!
  count: Int
}

type EntityIdentifierList implements Page {
  records: [EntityIdentifier]
  offset: Int!
  limit: Int!
  count: Int
}

type EntityIdentifierType {
  id: ID!
  label: String!
  labelPlural: String!
  iconClass: String
  description: String
  dataType: EntityIdentifierDataType!
  entityIdentifierItems: [EntityIdentifierItem]
}

type EntityIdentifierTypeList implements Page {
  records: [EntityIdentifierType!]
  limit: Int!
  offset: Int!
  count: Int
}

type EntityList implements Page {
  """The starting index for records that were returned in this query."""
  offset: Int!
  limit: Int!

  """Number of records returned in this response"""
  count: Int
  records: [Entity]
}

type EntitySummary {
  identifierCountsByType: JSON
}

type EntityType {
  name: String!
  namePlural: String!
  schema: JSON!
}

type Event {
  id: ID!
  eventName: String!
  eventType: String!
  application: String!
  public: Boolean!
  description: String
  schemaData: String!
  schemaHash: String!
  createdDateTime: DateTime!
  createdBy: String!
}

input EventDelivery {
  name: EventDeliveryType!
  params: JSON!
}

enum EventDeliveryType {
  """
  Webhook protocol should provide the following kvp in the json structure of
  "url":"<protocol>://<your_url>"
  "encoding":"[protobuf|protobuf_base64|json]
  "template": string
  """
  Webhook

  """
  SMS protocol should provide the following kvp in the json structure of
  "number": ##########
  """
  SMS

  """
  Email protocol should provide the following kvp in the json structure of
  "address":"<your_address>@<your_domain>"
  """
  Email
}

type EventList implements Page {
  records: [Event]

  """The starting index for records that were returned in this query."""
  offset: Int!
  limit: Int!

  """Number of records returned in this response"""
  count: Int
}

type ExecutionLocation {
  id: ID!
  clusterId: ID!
  cluster: Cluster!
  nodeId: ID
  node: ClusterNode
  data: JSON!
}

type ExecutionLocationList implements Page {
  records: [ExecutionLocation!]!
  count: Int!
  offset: Int!
  limit: Int!
}

type ExportFormat {
  """The file format/extension i.e. ttml, vlf, etc."""
  format: String!

  """
  A human readable label for the file format i.e. "Time Text Markup Language"
  """
  label: String!

  """
  A list types to categories the file format by i.e. "subtitle"
  """
  types: [String]!
}

type ExportRequest {
  """The unique ID of this export request"""
  id: ID!

  """Current status of this export request"""
  status: ExportRequestStatus!

  """ID of the organization this export request was issued for"""
  organizationId: ID!

  """Date/time at which this export request was created"""
  createdDateTime: DateTime!

  """Date/time at which this export request was last modified"""
  modifiedDateTime: DateTime!

  """ID of the user or API key that created this export request"""
  requestorId: ID!

  """
  The signed URI to the object that contains, or will contain,
  export results.
  """
  assetUri: String
}

enum ExportRequestEvent {
  exportRequest
  mentionExportRequest
}

type ExportRequestList implements Page {
  records: [ExportRequest!]!
  offset: Int!
  limit: Int!
  count: Int
}

enum ExportRequestStatus {
  incomplete
  complete
  downloaded
}

type ExternalCredential {
  id: ID!
  sourceTypeId: ID
  sourceType: SourceType
  data: StructuredData
  dataId: ID
}

type ExternalCredentialList implements Page {
  records: [ExternalCredential!]!
  count: Int!
  offset: Int!
  limit: Int!
}

type FileData implements Metadata {
  name: String!
  size: Int
  mimeType: String
  fileName: String
}

input FileTemporalDataObject {
  """ID of the TDO to file"""
  tdoId: ID!

  """ID of the new parent folder"""
  folderId: ID!

  """
  Order index determining in what order the new TDO will be displayed
  relative to other TDOs at the same level
  """
  orderIndex: Int = 0
}

input FileWatchlist {
  """ID of the TDO to file"""
  watchlistId: ID!

  """ID of the new parent folder"""
  folderId: ID!

  """
  Order index determining in what order the watchlist will be displayed
  relative to other objects at the same level
  """
  orderIndex: Int = 0
}

type Folder {
  """The ID of this folder"""
  id: ID!
  treeObjectId: ID!

  """The name of this folder"""
  name: String

  """An optional description"""
  description: String
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  ownerId: String

  """The parent folder"""
  parent: Folder

  """
  The subfolders of this folder
  Deprecated: Use paginated childFolders instead.
  """
  subfolders: [Folder!]

  """A paginated list of child folders of this folders"""
  childFolders(offset: Int = 0, limit: Int = 30): FolderList

  """The organization that owns this folder"""
  organization: Organization

  """The ID of the organization that owns this folder"""
  organizationId: ID
  typeId: Int
  rootFolderTypeId: Int

  """The maximum depth of child folders allowed"""
  maxDepth: Int
  orderIndex: Int

  """The folder status"""
  status: FolderStatus

  """
  The ordered path of the folder hierarchy. The first element
  is always a root folder, and the last is this folder's parent.
  """
  folderPath: [Folder!]

  """TemporalDataObjects that are filed in this folder"""
  childTDOs(offset: Int = 0, limit: Int = 30): TDOList

  """The read/write permissions for a shared folder"""
  sharedAccess: [String]
  sharedWith: SharedWith
  contentTemplates: [FolderContentTemplate!]!
}

type FolderContentTemplate {
  id: ID!
  folderId: ID!
  sdoId: ID!
  sdo: StructuredData
  schemaId: ID!
  data: JSON
  createdDateTime: DateTime
  modifiedDateTime: DateTime
}

type FolderList implements Page {
  records: [Folder]

  """
  Provide an offset to skip to a certain element in the result, for paging.
  """
  offset: Int!

  """
  Maximum number of results that were retrieved in this query; page size
  """
  limit: Int!

  """Number of records returned in this response"""
  count: Int
}

enum FolderStatus {
  active
  inactive
}

input GetCurrentUserPasswordToken {
  password: String
}

input getEngineJWT {
  """The ID of the engine that created the asset"""
  engineId: ID!

  """The set of IDs by resource type"""
  resource: GetEngineJWTResource!
}

input GetEngineJWTResource {
  tdoId: ID
  jobId: ID!
  taskId: ID!
}

input GetNextBundleForCluster {
  """ID of cluster need to get next bundle"""
  clusterId: ID!
}

"""
This type represents information about the Veritone GraphQL server
instance. Primarily used by Veritone engineering and operations.
"""
type GraphQLServiceInfo {
  """
  JSON structure containing build information, such as the build number and date.
  """
  buildInfo: JSON
  featureFlags: JSON
  heartbeatStats: JSON
}

type Group {
  id: ID!
  name: String
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  applicationId: ID!
  createdBy: User
  modifiedBy: User
  organizationId: ID!
  organization: Organization

  """Freeform metadata in JSON form"""
  jsondata: JSON
}

type GroupList implements Page {
  records: [Group]

  """The starting index for records that were returned in this query."""
  offset: Int!

  """
  Maximum number of results that were retrieved in this query; page size
  """
  limit: Int!

  """Number of records returned in this response"""
  count: Int
}

type IngestionConfiguration {
  id: ID!
  applicationId: ID!
  type: String
  name: String
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  emailAddress: String
  job: JSON
  ui: JSON
  jsondata: JSON
}

type IngestionConfigurationList implements Page {
  offset: Int!
  limit: Int!
  count: Int
  records: [IngestionConfiguration]
}

enum IntervalUnit {
  Months
  Weeks
  Days
  Hours
  Minutes
  Seconds
}

"""Type representing an integer property."""
type IntProperty implements Property {
  name: String!
  value: Int
}

type Job {
  """ID of the job"""
  id: ID!

  """User-provided job name"""
  name: String

  """Optional job description"""
  description: String
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  createdBy: String
  modifiedBy: String

  """ID of the target object for the job, such as a container or Recording"""
  targetId: ID

  """Source asset ID"""
  sourceAssetId: ID

  """
  Overall job status, as computed from the statuses of its component tasks
  """
  status: TaskStatus

  """Tasks the job has or will execute"""
  tasks(
    """Specify a list of job status strings to filter by status"""
    status: [TaskStatus!]

    """
    Provide an offset to skip to a certain element in the result, for paging.
    """
    offset: Int = 0

    """Maximum number of results to retrieve in this query"""
    limit: Int = 30

    """Specify an ID to retrieve a single specific task"""
    id: ID

    """Specify a list of IDs to filter by task target ID"""
    targetId: [ID]
    hasSourceAsset: Boolean
  ): TaskList

  """Application the job ran under"""
  applicationId: ID

  """Target TemporalDataObject"""
  target: TemporalDataObject

  """ID of the cluster where this job will be executed"""
  clusterId: ID
  jobConfig: JSON

  """ID of the template from which this job was created, if applicable."""
  templateId: ID

  """The template which this job was created, if applicable."""
  template: JobTemplate

  """
  ID of the scheduled job under which this job was created, if applicable.
  """
  scheduledJobId: ID

  """The scheduled job under which this job was created, if applicable."""
  scheduledJob: ScheduledJob
}

enum JobDateTimeField {
  createdDateTime
  modifiedDateTime
}

input JobDateTimeFilter {
  toDateTime: DateTime
  fromDateTime: DateTime
  field: JobDateTimeField!
}

type JobList implements Page {
  """Jobs retrieved"""
  records: [Job]

  """The starting index for records that were returned in this query."""
  offset: Int!

  """
  Maximum number of results that were retrieved in this query; page size
  """
  limit: Int!

  """Number of records returned in this response"""
  count: Int
}

enum JobOrderField {
  createdDateTime
  modifiedDateTime
}

type JobPipeline {
  """Unique ID of this job pipeline"""
  id: ID!

  """List of job templates associated with this job pipeline"""
  jobTemplates: JobTemplateList

  """ID of the organization that owns this job pipeline"""
  organizationId: ID

  """The organization that owns this job pipeline"""
  organization: Organization

  """
  Indicates whether or not this job pipeline is public. If so, it can
  be viewed and used, but not modified, by all organizations.
  """
  isPublic: Boolean!
}

type JobPipelineList implements Page {
  records: [JobPipeline!]!
  count: Int!
  offset: Int!
  limit: Int!
}

input JobSortField {
  field: JobOrderField!
  direction: OrderDirection = desc
}

enum JobStatus {
  pending
  complete
  running
  cancelled
  queued
}

enum JobStatusFilter {
  pending
  running
  complete
  cancelled
  queued
}

"""A job template is a reusable template for job creation."""
type JobTemplate {
  """The object ID"""
  id: ID!

  """Date and time this job template was created"""
  createdDateTime: DateTime

  """Date and time this job template was last modified"""
  modifiedDateTime: DateTime

  """Task templates associated with this job template"""
  taskTemplates(engineType: [EngineTypeFilter!], engineId: ID, offset: Int = 0, limit: Int = 30): TaskTemplateList!

  """Job pipeline ID that this template belongs to, if there is one"""
  jobPipelineId: ID

  """Job pipeline that this template belongs to, if there is one"""
  jobPipeline: JobPipeline

  """
  Job pipeline stage. Defined only if this template belongs to a job pipeline.
  """
  jobPipelineStage: Int

  """Target execution cluster ID"""
  clusterId: ID
  skipDecider: Boolean

  """
  Optional configuration data for jobs launched from the template.
  A schema may be enforced over the data stored here.
  Used for top-level information about the job that does not fit on
  a specific task template.
  """
  jobConfig: JSON
}

type JobTemplateList implements Page {
  records: [JobTemplate!]!
  count: Int!
  offset: Int!
  limit: Int!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

type JSONObject implements Metadata {
  name: String!
  data: JSON
}

"""Contains information about engineJWTToken context"""
type JWTTokenInfo {
  engineId: ID!
  token: String!
  resource: EngineJWTResource!
}

"""Key-value pairs -- a generic way to represent metadata"""
type KVP implements Metadata {
  name: String!
  value: [Property]
}

input LaunchJobTemplates {
  ids: [ID!]!
  scheduledJobId: ID
  payload: JSON
  targetInfo: LaunchJobTemplatesTargetInfo
}

input LaunchJobTemplatesTargetInfo {
  """
  ID of the target object for the jobs,
  typically that of a TemporalDataObject
  """
  targetId: ID!
  startOffsetMs: Int
  endOffsetMs: Int
}

input LaunchScheduledJobs {
  """
  Optional data about the job target,
  a TemporalDataObject. If this field is
  not specified then a suitable
  object will be created automatically.
  """
  targetInfo: CreateAllPipelineJobsTargetInfo

  """
  Optional data used to create a _new_ TDO for the job.
  Specify this field _or_ `targetInfo`, but not both.
  """
  createTargetInfo: CreateTDOForJob

  """Job payload"""
  payload: JSON
  scheduledJobId: ID
}

type Library {
  """Object creation timestamp. Does not change."""
  createdDateTime: DateTime

  """Object modification timestamp."""
  modifiedDateTime: DateTime

  """The object's unique ID"""
  id: ID!
  createdBy: String
  modifiedBy: String
  description: String
  name: String

  """Modular metadata in the form of key-value pairs"""
  properties: [Property]

  """Security settings for the asset container"""
  security: Security
  applicationId: ID!

  """Library version"""
  version: Int
  organizationId: ID
  libraryType: LibraryType
  libraryTypeId: ID
  coverImageUrl: String

  """Retrieve engine models for a library"""
  engineModels(id: ID): LibraryEngineModelList

  """Retrieve library model configurations"""
  configurations(limit: Int, offset: Int): LibraryConfigurationList

  """Retrieve dataset library tdos"""
  dataset: LibraryDataset
  entities(
    """Provide an ID to retrieve a single specific entity."""
    id: ID
    ids: [ID!]
    isPublished: Boolean
    identifierTypeId: ID
    name: String
    offset: Int = 0
    limit: Int = 30
    orderBy: LibraryEntityOrderBy
    orderDirection: OrderDirection
  ): EntityList

  """Retrieve collaborators for a library."""
  collaborators(
    """
    Provide an ID to retrieve collaborators within a specific organization.
    """
    collaboratorOrgId: ID
  ): LibraryCollaboratorList

  """Aggregated summary data about the library"""
  summary: LibrarySummary
}

type LibraryCollaborator {
  organizationId: ID!
  organization: Organization
  status: String
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  permissions: [String]
  libraryId: ID!
  library: Library
}

type LibraryCollaboratorList {
  records: [LibraryCollaborator]

  """The starting index for records that were returned in this query."""
  offset: Int!
  limit: Int!

  """Number of records returned in this response"""
  count: Int
}

type LibraryConfiguration {
  """library configuration id"""
  id: ID

  """ID of the selected library where this config applies to"""
  libraryId: ID

  """ID of the engine category this config applies to"""
  engineCategoryId: ID

  """List of selected engine ids for training"""
  targetEngineIds: [ID]

  """
  This option is used for Dataset Library Only
  List of selected engine where tdos are extracted from for training data
  TDOs are extracted from higher ranked engines first then fallback to the lower
  ones if the priors don't have any matching tdo
  """
  rankedSourceEngineIds: [ID]

  """
  This option is used for Dataset Library Only
  Dataset tdos confidence filters
  """
  confidence: DatasetConfidence
}

type LibraryConfigurationList implements Page {
  """The starting index for records that were returned in this query."""
  offset: Int!
  limit: Int!

  """Number of records returned in this response"""
  count: Int
  records: [LibraryConfiguration]
}

type LibraryDataset {
  """Id of the selected library"""
  libraryId: ID

  """List of tdo ids in the selected library"""
  tdoIds: [ID]
}

type LibraryEngineModel {
  id: ID!
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  engineId: ID!
  engine: Engine
  libraryId: ID!
  library: Library
  libraryVersion: Int
  trainJobId: ID
  trainStatus: LibraryEngineModelTrainStatus!
  dataUrl: String

  """
  Content type of the data file pointed to by dataUrl.
  Will be empty if no data file is attached to the engine model.
  """
  contentType: String
  jsondata: JSON
  accuracy: Int
  configurationId: ID
}

type LibraryEngineModelList implements Page {
  records: [LibraryEngineModel]
  offset: Int!
  limit: Int!
  count: Int
}

enum LibraryEngineModelTrainStatus {
  pending
  queued
  complete
  failed
  running
}

enum LibraryEntityOrderBy {
  id
  name
  createdDateTime
  modifiedDateTime
}

type LibraryList implements Page {
  """The starting index for records that were returned in this query."""
  offset: Int!
  limit: Int!

  """Number of records returned in this response"""
  count: Int
  records: [Library]
}

enum LibraryOrderBy {
  id
  name
  createdDateTime
  modifiedDateTime
  version
}

type LibrarySummary {
  entityCount: Int
  unpublishedEntityCount: Int
  lastTrainedVersion: Int
  lastTrainedDateTime: DateTime
}

type LibraryType {
  id: ID!
  label: String
  iconClass: String
  entityIdentifierTypes: [EntityIdentifierType]
  entityTypeName: String
  entityTypeNamePlural: String
  entityType: EntityType
}

type LibraryTypeList implements Page {
  """The starting index for records that were returned in this query."""
  offset: Int!
  limit: Int!

  """Number of records returned in this response"""
  count: Int
  records: [LibraryType]
}

"""Contains information about the user's authentication context."""
type LoginInfo {
  """
  API token. This is a persistent organization-level token intended for API access.
  """
  apiToken: String

  """
  Session-scoped user token. This token is tied to the user's session and will expire
  when that session ends.
  """
  token: String

  """
  Date and time at which the user last logged in to the Veritone platform
  """
  lastLoggedIn: String

  """
  List of Veritone platform applications for which the user is provisioned.
  Note that these are different than the VDA custom applications referenced
  in the `Application` type, `applications()` query, and related mutations.
  """
  applications: [ID]
  applicationPlatforms: [ApplicationPlatform]

  """Groups to which the user belongs."""
  groups: [Group]

  """
  True if the user account has a password set. False otherwise.
  If false, the user will be prompted to set a password on next login.
  """
  hasPassword: Boolean

  """Organization to which the user belongs."""
  organization: Organization

  """True if a password reset will be required on the user's next login."""
  passwordResetRequired: Boolean

  """TODO"""
  providerId: String

  """TODO"""
  providerScreenName: String

  """TODO"""
  providerUserId: String

  """User object"""
  user: User
}

type MediaShare {
  mediaType: String!
  serviceName: String!

  """sourceId OR tdoId is required"""
  sourceId: ID
  tdoId: ID
  scheduledJobId: ID
  startDateTime: DateTime
  stopDateTime: DateTime
  startOffsetMs: Int
  stopOffsetMs: Int

  """
  various settings for diffrent types of media. like audio only for videos
  """
  settings: JSON
}

type MediaShareInfo {
  token: String!
  isSegmented: Boolean
}

enum MediaStorageOption {
  edge
  core
}

type Mention {
  id: ID!
  organizationId: ID!
  sourceTypeId: ID
  sourceId: ID
  scheduleId: ID
  mediaId: ID
  advertiserId: ID
  brandId: ID
  campaignId: ID
  watchlistId: ID
  statusId: ID
  complianceStatusId: ID
  spotTypeId: ID
  audienceMarketCount: Int
  audienceAffiliateCount: Int
  mentionHitCount: Int
  audience: Int
  mentionRating: Int
  isMatch: Boolean
  mentionDate: DateTime
  metadata: JSON
  mentionSnippets: [MentionSnippets]
  userSnippets: [MentionUserSnippets]
  adCreative: JSON
  fingerprint: JSON
  cognitiveEngineResults: JSON
  comments: MentionCommentList
  hash: ID
  hitStartDateTime: DateTime
  hitEndDateTime: DateTime
  endDateTime: DateTime
  scheduledJob: ScheduledJob
  temporalDataObject: TemporalDataObject
  organization: Organization!
  watchlist: Watchlist
  advertiser: JSON
  brand: JSON
  queryTerm: String
  ratings(userId: ID): MentionRatingList
  privateNote: String
  publicNote: String
  campaign: Campaign
}

type MentionComment {
  commentId: ID!
  mentionId: ID
  userId: ID
  firstName: String
  lastName: String
  userImage: String
  commentText: String
  createdDateTime: DateTime
  modifiedDateTime: DateTime
}

type MentionCommentList implements Page {
  offset: Int!
  limit: Int!
  count: Int
  records: [MentionComment]
}

enum MentionDateTimeField {
  mentionDate
  endDateTime
  hitStartDateTime
  hitStopDateTime
}

input MentionDateTimeFilter {
  toDateTime: DateTime
  fromDateTime: DateTime
  field: MentionDateTimeField!
}

type MentionHit {
  queryTerm: String
  startTime: Float
  endTime: Float
}

type MentionList implements Page {
  offset: Int!
  limit: Int!
  count: Int
  records: [Mention!]
}

input MentionOrderBy {
  field: MentionOrderByField!
  direction: OrderDirection = desc
}

enum MentionOrderByField {
  id
  mentionDate
  hitStartDateTime
  hitEndDateTime
  endDateTime
}

type MentionRating {
  ratingId: ID!
  mentionId: ID
  userId: ID
  ratingValue: Int
  createdDateTime: DateTime
  modifiedDateTime: DateTime
}

type MentionRatingList implements Page {
  offset: Int!
  limit: Int!
  count: Int
  records: [MentionRating]
}

type MentionSnippets {
  text: String
  startTime: Float
  endTime: Float
  hits: [MentionHit]
}

type MentionStatus {
  id: ID!
  name: String!
}

type MentionUserSnippets {
  text: String
  startTime: Float
  endTime: Float
  transcriptStartDate: DateTime
  transcriptEndDate: DateTime
  snippets: [MentionSnippets]
}

interface Metadata {
  name: String!
}

"""Type that holds multi-factor authentication for a user"""
type MFAInfo {
  phoneNumber: String
  smsVoiceVerifiedDateTime: DateTime
  gaVerifiedDateTime: DateTime
  defaultOption: String
  pendingRegistration: String
}

"""Move a folder into a new parent folder."""
input MoveFolder {
  treeObjectId: ID!
  prevParentTreeObjectId: ID!
  newParentTreeObjectId: ID!
  newOrderIndex: Int!
  prevOrderIndex: Int!
  rootFolderType: RootFolderType = watchlist
}

input MoveTemporalDataObject {
  """ID of the TDO to move"""
  tdoId: ID!

  """
  ID of the original parent folder. The TDO will be removed from this folder.
  """
  oldFolderId: ID!

  """ID of the new parent folder. The TDO will be added to this folder."""
  newFolderId: ID!
}

"""
Mutations are used to modify data. Each mutation takes an input
that contains the data necessary to create or update the data
in question.
"""
type Mutation {
  """Create a new temporal data object"""
  createTDO(
    """Fields required to create a TDO"""
    input: CreateTDO
  ): TemporalDataObject

  """Update a temporal data object"""
  updateTDO(
    """Fields required to update a TDO"""
    input: UpdateTDO
  ): TemporalDataObject

  """
  Delete a temporal data object. The TDO metadata, its assets and
  all storage objects, and search index data are deleted.
  Engine results stored in related task objects are not.
  cleanupTDO can be used to selectively delete certain data on the TDO.
  """
  deleteTDO(
    """Supply the ID of the TDO to delete"""
    id: ID!
  ): DeletePayload

  """
  Delete partial information from a temporal data object.
  Use the delete options to control exactly which data is deleted.
  The default is to delete objects from storage and the search index,
  while leaving TDO-level metadata and task engine results intact.
  To permanently delete the TDO, use delete TDO.
  """
  cleanupTDO(
    """Supply the ID of the TDO to clean up."""
    id: ID!

    """
    Supply a list of cleanup options. See TDOCleanupOption
    for details. If not provided, the server will use default settings.
    """
    options: [TDOCleanupOption!] = [storage, searchIndex]
  ): DeletePayload

  """
  Create a task log by using
  multipart form POST.
  """
  createTaskLog(
    """Fields needed to create a task log."""
    input: CreateTaskLog!
  ): TaskLog

  """
  Create a media asset. Optionally, upload content using
  multipart form POST.
  """
  createAsset(
    """Fields needed to create an asset."""
    input: CreateAsset!
  ): Asset

  """Delete an asset"""
  deleteAsset(
    """Provide the ID of the asset to delete."""
    id: ID!
  ): DeletePayload

  """Update an asset"""
  updateAsset(
    """Fields needed to update an asset."""
    input: UpdateAsset!
  ): Asset

  """
  Add a single media segment to a TemporalDataObject.
  This mutation will update the manifest asset (`media-mdp`)
  for the TemporalDataObject.
  """
  addMediaSegment(
    """Fields necesary to create the segment."""
    input: AddMediaSegment!
  ): TemporalDataObject!

  """
  Start a clone job. A clone creates a new TDO
  that links back to an existing TDO's assets
  instead of creating new ones and is used
  primarily to handle sample media.
  """
  requestClone(
    """Fields needed to request a new clone job."""
    input: RequestClone
  ): CloneRequest

  """
  Create a new engine. The engine will need to go
  through a sequence of workflow steps before
  use in production. See VDA documentation for details.
  """
  createEngine(
    """Fields needed to create a new engine"""
    input: CreateEngine
  ): Engine

  """
  Update an engine. Engines are subject to specific
  workflow steps. An engine's state determines what
  updates can be made to it. See VDA documentation for
  details.
  """
  updateEngine(
    """Fields needed to update an engine"""
    input: UpdateEngine
  ): Engine

  """Delete an engine"""
  deleteEngine(
    """Provide the ID of the engine to delete"""
    id: ID!
  ): DeletePayload

  """Create an engine build."""
  createEngineBuild(
    """Fields needed to create an engine build."""
    input: CreateBuild!
  ): Build

  """
  Update an engine build. Engine builds are subject to
  specific workflow steps. A build's state determines what
  updates can be made to it. See VDA documentation for details.
  """
  updateEngineBuild(
    """Fields needed to update an engine build."""
    input: UpdateBuild!
  ): Build

  """Delete an engine build"""
  deleteEngineBuild(
    """Fields needed to delete an engine build."""
    input: DeleteBuild!
  ): DeletePayload

  """Update a task"""
  updateTask(
    """Fields required to update a task."""
    input: UpdateTask
  ): Task
  addTasksToJobs(input: AddTasksToJobs): AddTasksToJobsResponse

  """Poll a task"""
  pollTask(
    """Fields required to poll a task."""
    input: PollTask
  ): Task

  """Create a job"""
  createJob(
    """Fields required to create a job."""
    input: CreateJob
  ): Job

  """
  Cancel a job. This action effectively deletes the job,
  although a records of job and task execution remains in
  Veritone's database.
  """
  cancelJob(
    """Supply the ID of the job to delete."""
    id: ID!
  ): DeletePayload

  """
  Retry a job. This action applies only to jobs
  that are in a failure state. The task sequence
  for the job will be restarted in its original
  configuration.
  """
  retryJob(
    """Supply the ID of the job to retry."""
    id: ID!
  ): Job
  updateJobs(input: UpdateJobs!): JobList

  """
  Create a new application. An application must
  go through a sequence of workflow steps before
  it is available in production. See the VDA documentation
  for details.
  """
  createApplication(
    """Fields needed to create a new custom application."""
    input: CreateApplication
  ): Application

  """Delete an application"""
  deleteApplication(
    """Supply the ID of the application to delete."""
    id: ID!
  ): DeletePayload

  """
  Update a custom application. Applications are subject to
  specific workflows. The current application state determines
  what updates can be made to it. See VDA documentation for details.
  """
  updateApplication(
    """Fields required to update a custom application."""
    input: UpdateApplication
  ): Application

  """Bulk delete context meu extensions."""
  bulkDeleteContextMenuExtensions(input: BulkDeleteContextMenuExtensions): ContextMenuExtensionList

  """Update an organization"""
  updateOrganization(
    """Fields required to update an organization."""
    input: UpdateOrganization!
  ): Organization
  addToEngineWhitelist(toAdd: SetEngineWhitelist!): EngineWhitelist
  addToEngineBlacklist(toAdd: SetEngineBlacklist!): EngineBlacklist
  deleteFromEngineBlacklist(toDelete: SetEngineBlacklist!): EngineBlacklist
  deleteFromEngineWhitelist(toDelete: SetEngineBlacklist!): EngineWhitelist

  """
  Create an entity identifier type, such as "face" or "image".
  Entity identifier types are typically created or modified
  only by Veritone engineering. Most libraries and
  entities will use existing entity identifier types.
  """
  createEntityIdentifierType(
    """Fields required to create an entity identifier type."""
    input: CreateEntityIdentifierType!
  ): EntityIdentifierType

  """Update an entity identifier type."""
  updateEntityIdentifierType(
    """Fields required to update an entity identifier type."""
    input: UpdateEntityIdentifierType!
  ): EntityIdentifierType

  """
  Create a library type, such as "ad" or "people".
  Entity identifier types are typically created or modified
  only by Veritone engineering. Most libraries
  will use existing entity identifier types.
  """
  createLibraryType(
    """Fields needed to create a new library type."""
    input: CreateLibraryType!
  ): LibraryType

  """Update a library type."""
  updateLibraryType(
    """Fields needed to update a library type."""
    input: UpdateLibraryType!
  ): LibraryType

  """
  Create a new library.
  Once the library is created, the client can add
  entities and entity identifiers. Note that the
  library type determines what types of entity identifiers
  can be used within the library.
  """
  createLibrary(
    """Fields needed to create a new library."""
    input: CreateLibrary!
  ): Library

  """Update an existing library."""
  updateLibrary(
    """Fields needed to update a library"""
    input: UpdateLibrary!
  ): Library

  """
  Delete a library. This mutation will also delete all entities,
  entity identifiers, library engine models, and associated objects.
  """
  deleteLibrary(
    """Provide the ID of the library to delete."""
    id: ID!
  ): DeletePayload

  """
  Publish a new version of a library.
  Increments library version by one and trains compatible engines.
  """
  publishLibrary(
    """ID of the library to publish"""
    id: ID!
  ): Library

  """Create a new entity."""
  createEntity(
    """Fields required to create a new entity."""
    input: CreateEntity!
  ): Entity

  """Update an entity."""
  updateEntity(
    """Fields required to update an entity."""
    input: UpdateEntity!
  ): Entity

  """
  Delete an entity. This mutation will also delete all associated
  entity identifiers and associated objects.
  """
  deleteEntity(
    """Supply the ID of the entity to delete."""
    id: ID!
  ): DeletePayload

  """
  Create an entity identifier.
  This mutation accepts file uploads. To use this mutation and upload a file,
  send a multipart form POST containing two parameters:  `query`, with the
  GraphQL query, and `file` containing the file itself.
  For more information see the documentation at https://veritone-developer.atlassian.net/wiki/spaces/DOC/pages/13893791/GraphQL.
  """
  createEntityIdentifier(
    """Fields needed to create an entity identifier."""
    input: CreateEntityIdentifier!
  ): EntityIdentifier
  updateEntityIdentifier(
    """Fields required to update an entity identifier."""
    input: UpdateEntityIdentifier!
  ): EntityIdentifier

  """Delete an entity identifier"""
  deleteEntityIdentifier(
    """Supply the ID of the entity identifier to delete."""
    id: ID!
  ): DeletePayload

  """Create a library engine model."""
  createLibraryEngineModel(
    """Fields required to create a library engine model."""
    input: CreateLibraryEngineModel!
  ): LibraryEngineModel

  """Update a library engine model"""
  updateLibraryEngineModel(
    """Fields required to update a library engine model"""
    input: UpdateLibraryEngineModel!
  ): LibraryEngineModel

  """Delete a library engine model"""
  deleteLibraryEngineModel(
    """Supply the ID of the library engine model to delete."""
    id: ID!
  ): DeletePayload

  """Create Dataset Library Configuration"""
  createLibraryConfiguration(
    """Fields required to create library configuration"""
    input: CreateLibraryConfiguration!
  ): LibraryConfiguration

  """Update Dataset Library Configuration"""
  updateLibraryConfiguration(
    """Fields required to create library configuration"""
    input: UpdateLibraryConfiguration!
  ): LibraryConfiguration

  """Delete Dataset Library Configuration"""
  deleteLibraryConfiguration(
    """Supply configuration ID to delete."""
    id: ID!
  ): DeletePayload

  """Add recordings to a dataset library"""
  addLibraryDataset(input: AddLibraryDataset!): LibraryDataset

  """Remove recordings from a dataset library"""
  deleteLibraryDataset(input: DeleteLibraryDataset!): DeleteLibraryDatasetPayload

  """
  Apply an application workflow step, such as "submit" or "approve"
  """
  applicationWorkflow(
    """Fields required to apply a application workflow step"""
    input: ApplicationWorkflow
  ): Application

  """
  Apply an application workflow step, such as "submit" or "approve"
  """
  engineWorkflow(
    """Fields required to apply a engine workflow step"""
    input: EngineWorkflow
  ): Engine

  """Create an ingestion configuration"""
  createIngestionConfiguration(input: CreateIngestionConfiguration): IngestionConfiguration

  """Update an ingestion configuration"""
  updateIngestionConfiguration(input: UpdateIngestionConfiguration): IngestionConfiguration

  """Delete an ingestion configuration"""
  deleteIngestionConfiguration(
    """ID of the ingestion configuration to delete"""
    id: ID!
  ): DeletePayload

  """Creates a widget associated with a collection"""
  createWidget(
    """Fields needed to create a new widget"""
    input: CreateWidget
  ): Widget

  """Updates a widget"""
  updateWidget(
    """Fields needed to update a widget"""
    input: UpdateWidget
  ): Widget

  """Create a new user within an organization."""
  createUser(
    """Fields needed to create a user."""
    input: CreateUser
  ): User

  """Create a new organization."""
  createOrganization(
    """Fields needed to create an organization."""
    input: CreateOrganization!
  ): Organization

  """Update an existing user"""
  updateUser(
    """Fields needed to update a user"""
    input: UpdateUser
  ): User

  """
  Force a user to update password on next login.
  This mutation is used by administrators.
  """
  createPasswordUpdateRequest(
    """Fields needed to create a password update request"""
    input: CreatePasswordUpdateRequest
  ): User

  """Get password token info for current user"""
  getCurrentUserPasswordToken(input: GetCurrentUserPasswordToken!): PasswordTokenInfo!

  """
  Create a password reset request. This mutation is used on behalf
  of a user who needs to reset their password. It operates only on
  the currently authenicated user (based on the authentication token provided).
  """
  createPasswordResetRequest(input: CreatePasswordResetRequest): CreatePasswordResetRequestPayload

  """Update the current authenticated user"""
  updateCurrentUser(input: UpdateCurrentUser!): User!

  """Change the current authenticated user's password"""
  changePassword(
    """Fields needed to change password"""
    input: ChangePassword!
  ): User

  """Delete a user"""
  deleteUser(
    """Supply the ID of the user to delete."""
    id: ID!
  ): DeletePayload

  """Create a structured data registry schema metadata."""
  createDataRegistry(input: CreateDataRegistry!): DataRegistry

  """Update a structured data registry schema metadata."""
  updateDataRegistry(input: UpdateDataRegistry!): DataRegistry

  """Update a structured data registry schema."""
  upsertSchemaDraft(input: UpsertSchemaDraft!): Schema
  updateSchemaState(input: UpdateSchemaState!): Schema

  """Create (ingest) a structured data object"""
  createStructuredData(input: CreateStructuredData!): StructuredData

  """Delete a structured data object"""
  deleteStructuredData(input: DeleteStructuredData!): DeletePayload

  """Create (ingest) a structured data object"""
  createCollection(
    """Fields required to create new collection"""
    input: CreateCollection
  ): Collection

  """Update a collection"""
  updateCollection(
    """Fields needed to update a collection"""
    input: UpdateCollection
  ): Collection

  """Delete Collection"""
  deleteCollection(
    """@deprecated(reason: "folderId has been renamed to id. Use id.")"""
    folderId: ID

    """Supply the ID of the folder or collection to delete"""
    id: ID
  ): DeletePayload

  """
  Share a collection, allowing other organizations to view the data
  it contains.
  """
  shareCollection(
    """Fields needed to share a collection"""
    input: ShareCollection
  ): Share

  """Share a mention from a collection"""
  shareMentionFromCollection(
    """Fields needed to share a mention"""
    input: ShareMentionFromCollection
  ): Share

  """Share mention"""
  shareMention(input: ShareMention): Share

  """Share mentions in bulk"""
  shareMentionInBulk(input: ShareMentionInBulk): [Share]

  """Add a mention to a collection"""
  createCollectionMention(
    """Fields needed to add a mention to a collection"""
    input: CollectionMentionInput
  ): CollectionMention
  createCollectionMentions(
    """Fields needed to add mentions to a collection"""
    input: CreateCollectionMentions
  ): [CollectionMention!]!

  """Remove a mention from a collection"""
  deleteCollectionMention(
    """Fields needed to delete a mention from a collection"""
    input: CollectionMentionInput
  ): CollectionMention

  """Create a new folder"""
  createFolder(
    """Fields needed to create a new folder."""
    input: CreateFolder
  ): Folder

  """Update an existing folder"""
  updateFolder(
    """Fields needed to update a folder."""
    input: UpdateFolder
  ): Folder

  """Move a folder from one parent folder to another."""
  moveFolder(
    """Fields needed to move a folder"""
    input: MoveFolder
  ): Folder

  """Delete a folder"""
  deleteFolder(
    """Fields needed to delete a folder"""
    input: DeleteFolder
  ): DeletePayload

  """Create a mention comment"""
  createMentionComment(
    """Fields needed to create a mention comment"""
    input: CreateMentionComment
  ): MentionComment

  """Update a mention comment"""
  updateMentionComment(
    """Fields needed to update a mention comment"""
    input: UpdateMentionComment
  ): MentionComment

  """Delete a mention comment"""
  deleteMentionComment(
    """Fields needed to delete a mention comment"""
    input: DeleteMentionComment
  ): DeletePayload

  """Create a mention rating"""
  createMentionRating(
    """Fields needed to create a mention rating"""
    input: CreateMentionRating
  ): MentionRating

  """Update a mention rating"""
  updateMentionRating(
    """Fields needed to update a mention rating"""
    input: UpdateMentionRating
  ): MentionRating

  """Delete a mention rating"""
  deleteMentionRating(
    """Fields needed to delete a mention rating."""
    input: DeleteMentionRating
  ): DeletePayload

  """
  Login as a user. This mutation does not require an existing authentication
  context (via `Authorization` header with bearer token, cookie, etc.).
  Instead, the client supplies credentials to this mutation, which then
  authenticates the user and sets up the authentication context.
  The returned tokens can be used to authenticate future requests.
  """
  userLogin(
    """Fields needed to log in"""
    input: UserLogin
  ): LoginInfo

  """Logout user and invalidate user token"""
  userLogout(
    """User token that should be invalidated"""
    token: String!
  ): Boolean

  """
  Refresh a user token, returning a fresh token so that the client
  can continue to authenticate to the API.
  """
  refreshToken(token: String!): LoginInfo

  """
  Validate a user token. This mutation is used by services to determine
  if the token provided by a given client is valid.
  """
  validateToken(token: String!): LoginInfo

  """Create a mention object"""
  createMention(input: CreateMention!): Mention

  """Update a mention object"""
  updateMention(input: UpdateMention!): Mention

  """Update a set of mentions"""
  updateMentions(input: UpdateMentions!): [Mention]

  """Create root folder for an organization"""
  createRootFolders(
    """The type of root folder to create"""
    rootFolderType: RootFolderType = watchlist
  ): [Folder]

  """
  Apply bulk updates to watchlists.
  This mutation is currently available only to Veritone operations.
  """
  bulkUpdateWatchlist(
    """
    A filter indicating which watchlists should be updated.
    At least one filter condition must be provided.
    Only watchlists for the user's organization will be updated.
    """
    filter: BulkUpdateWatchlistFilter!

    """Fields used to update a watchlist."""
    input: BulkUpdateWatchlist
  ): WatchlistList

  """
  File a TemporalDataObject in a folder. A given TemporalDataObject can
  be filed in any number of folders, or none. Filing causes the TemporalDataObject
  and its assets to be visible within the folder.
  """
  fileTemporalDataObject(
    """The fields needed to file a TemporalDataObject in a folder"""
    input: FileTemporalDataObject!
  ): TemporalDataObject

  """
  Unfile a TemporalDataObject from a folder. This causes the TemporalDataObject
  and its assets to disappear from the folder, but does not otherwise affect
  either the TDO or the folder and does not change access controls.
  """
  unfileTemporalDataObject(
    """The fields needed to file a TemporalDataObject in a folder"""
    input: UnfileTemporalDataObject!
  ): TemporalDataObject

  """
  Moves a TemporalDataObject from one parent folder to another.
  Any other folders the TemporalDataObject is filed in are unaffected.
  """
  moveTemporalDataObject(
    """Fields need to move a TemporalDataObject"""
    input: MoveTemporalDataObject!
  ): TemporalDataObject

  """
  Upload and store an engine result. The result will be stored as an
  asset associated with the target TemporalDataObject and the
  task will be updated accordingly.
  Use a multipart form POST to all this mutation.
  """
  uploadEngineResult(
    """Fields needed to upload and store an engine result"""
    input: UploadEngineResult!
  ): Asset
  createWatchlist(input: CreateWatchlist!): Watchlist
  updateWatchlist(input: UpdateWatchlist!): Watchlist
  deleteWatchlist(id: ID!): DeletePayload
  updateCognitiveSearch(input: UpdateCognitiveSearch): CognitiveSearch
  createCognitiveSearch(input: CreateCognitiveSearch): CognitiveSearch
  deleteCognitiveSearch(id: ID!): DeletePayload
  fileWatchlist(input: FileWatchlist!): Watchlist
  unfileWatchlist(input: UnfileWatchlist!): Watchlist

  """Share a folder with other organizations"""
  shareFolder(input: ShareFolderInput): Folder

  """Create a TDO and an asset with a single call"""
  createTDOWithAsset(
    """Input fields necessary to create the TDO and asset"""
    input: CreateTDOWithAsset
  ): TemporalDataObject
  createSubscription(input: CreateSubscription!): Subscription
  updateSubscription(input: UpdateSubscription!): Subscription
  deleteSubscription(id: ID!): DeletePayload

  """Create trigger for events or types."""
  createTriggers(input: CreateTriggers!): [Trigger]

  """Delete a registed trigger by ID."""
  deleteTrigger(id: ID!): DeletePayload

  """
  Validates if an engine output conforms to the engine output guidelines
  """
  validateEngineOutput(input: JSON!): Boolean!

  """
  JWT tokens with a more limited scoped token to specific
  resources to the recording, task, and job
  and also has no organization association.
  """
  getEngineJWT(input: getEngineJWT!): JWTTokenInfo!

  """Verify JWT token"""
  verifyJWT(jwtToken: String!): VerifyJWTPayload

  """Create a new Saved Search"""
  createSavedSearch(input: CreateSavedSearch!): SavedSearch!

  """Delete a saved search"""
  deleteSavedSearch(id: ID!): DeletePayload!

  """
  Mark existing saved search profile as deleted
  Create new saved search profile
  """
  replaceSavedSearch(input: ReplaceSavedSearch!): SavedSearch!

  """Send a basic email. Mutation returns true for a success message."""
  sendEmail(input: SendEmail!): Boolean!

  """Create new content template into a folder"""
  createFolderContentTempate(input: CreateFolderContentTempate!): FolderContentTemplate!

  """Update existing content template by folderContentTemplateId"""
  updateFolderContentTempate(input: UpdateFolderContentTempate!): FolderContentTemplate!

  """Delete existing folder content template by folderContentTemplateId"""
  deleteFolderContentTempate(
    """Folder Content Template Id"""
    id: ID!
  ): DeletePayload!

  """
  Create an export request. The requested TDO data, possibly including
  TDO media and engine results, will be exported offline.
  """
  createExportRequest(
    """Input data required to create the export request"""
    input: CreateExportRequest!
  ): ExportRequest!

  """Update an export request"""
  updateExportRequest(
    """Input data required to update an export request"""
    input: UpdateExportRequest!
  ): ExportRequest!

  """
  Create Mention in bulk. The input should be an array of createMentions
  """
  createMentions(input: CreateMentions!): MentionList

  """Create Media Share. Returning the url of the share"""
  createMediaShare(input: CreateMediaShare!): CreatedMediaShare!

  """Create or Update Workflow data."""
  setWorkflowRuntimeStorageData(workflowRuntimeId: ID!, input: CreateWorkflowRuntimeStorageData!): WorkflowRuntimeStorageData!

  """Create a new event"""
  createEvent(input: CreateEvent!): Event!

  """Update an event"""
  updateEvent(input: UpdateEvent!): Event!

  """Subscribe to an event"""
  subscribeEvent(input: SubscribeEvent!): ID!

  """Unsubscribe to an event"""
  unsubscribeEvent(id: ID!): UnsubscribeEvent!

  """Emit an event"""
  emitEvent(input: EmitEvent!): EmitEventResponse!

  """Start a Veritone Workflow instance"""
  startWorkflowRuntime(workflowRuntimeId: ID!, orgId: ID!, generateAuthToken: Boolean = false): WorkflowRuntimeResponse!

  """Shutdown Veritone Workflow instance"""
  stopWorkflowRuntime(workflowRuntimeId: ID!): WorkflowRuntimeResponse!

  """Create a processTemplate in CMS"""
  createProcessTemplate(input: CreateProcessTemplate!): ProcessTemplate!

  """Update a processTemplate by ID in CMS"""
  updateProcessTemplate(input: UpdateProcessTemplate!): ProcessTemplate!

  """Delete a processTemplate by ID in CMS"""
  deleteProcessTemplate(id: ID!): DeletePayload!

  """
  Create a mention export request. The requested mentionFilters including
  The mention export file csv will be exported offline.
  """
  createMentionExportRequest(
    """Input data required to create the export request"""
    input: CreateMentionExportRequest!
  ): ExportRequest!

  """
  Update status or assetURI of a mentionExportRequest
  Often use when the file export was completed or downloaded
  """
  updateMentionExportRequest(input: UpdateMentionExportRequest!): ExportRequest!

  """Create a creative"""
  createCreative(input: CreateCreative!): Creative!

  """Update a creative"""
  updateCreative(input: UpdateCreative!): Creative!

  """Delete a creative"""
  deleteCreative(id: ID!): DeletePayload!

  """
  Emit a system-level emit. This mutation is used only by
  Veritone platform components.
  """
  emitSystemEvent(
    """Data required to create the event"""
    input: EmitSystemEvent!
  ): SystemEventInfo!
  createCluster(input: CreateCluster!): Cluster
  updateCluster(input: UpdateCluster!): Cluster
  deleteCluster(id: ID!): DeletePayload
  pauseCluster(input: PauseCluster!): Cluster
  unpauseCluster(input: UnpauseCluster!): Cluster
  createClusterNode(input: CreateClusterNode!): ClusterNode
  updateClusterNode(input: UpdateClusterNode!): ClusterNode
  deleteClusterNode(id: ID!): DeletePayload
  createScheduledJob(input: CreateScheduledJob!): ScheduledJob!
  cloneScheduledJob(input: CloneScheduledJob!): ScheduledJob!
  revertScheduledJob(input: RevertScheduledJob!): ScheduledJob!
  updateScheduledJob(input: UpdateScheduledJob!): ScheduledJob!
  deleteScheduledJob(id: ID!): DeletePayload

  """Create a new content template on a scheduled job"""
  createScheduledJobContentTemplate(input: CreateScheduledJobContentTemplate!): ScheduledJobContentTemplate!
  deleteScheduledJobContentTemplate(
    """
    ID of the scheduled job content template to delete. It will be removed from the
    scheduled job. The underlying SDO will not be deleted.
    """
    id: ID!
  ): DeletePayload

  """Create a new source"""
  createSource(input: CreateSource!): Source
  updateSource(input: UpdateSource!): Source
  deleteSource(id: ID!): DeletePayload

  """Create a new source content template on a source"""
  createSourceContentTemplate(input: CreateSourceContentTemplate!): SourceContentTemplate!
  deleteSourceContentTemplate(
    """
    ID of the source content template to delete. It will be removed from the
    source. The underlying SDO will not be deleted.
    """
    id: ID!
  ): DeletePayload
  createSourceType(input: CreateSourceType!): SourceType
  updateSourceType(input: UpdateSourceType!): SourceType
  deleteSourceType(id: ID!): DeletePayload
  createJobPipeline(input: CreateJobPipeline!): JobPipeline!
  updateJobPipeline(input: UpdateJobPipeline!): JobPipeline!
  deleteJobPipeline(id: ID!): DeletePayload
  createJobTemplate(input: CreateJobTemplate!): JobTemplate!
  updateJobTemplate(input: UpdateJobTemplate!): JobTemplate!
  deleteJobTemplate(id: ID!): DeletePayload
  createTaskTemplate(input: CreateTaskTemplate!): TaskTemplate!
  updateTaskTemplate(input: UpdateTaskTemplate!): TaskTemplate!
  deleteTaskTemplate(id: ID!): DeletePayload
  createNextPipelineJobs(input: CreateNextPipelineJobs!): [Job]

  """Creates one or more jobs based on the supplied scheduled job."""
  launchScheduledJobs(input: LaunchScheduledJobs!): [Job]

  """Creates one or more jobs based on the supplied job templates."""
  launchJobTemplates(input: LaunchJobTemplates!): [Job]

  """Get next bundle for cluster."""
  getNextBundleForCluster(input: GetNextBundleForCluster!): Bundle!

  """Update bundle status as cluster."""
  updateBundleStatusAsCluster(input: updateBundleStatusAsCluster): Bundle!

  """Pause for a node"""
  pauseClusterNode(input: PauseClusterNode!): ClusterNode

  """Unpause for a node"""
  unpauseClusterNode(input: UnpauseClusterNode!): ClusterNode

  """
  Update the cluster's runtime state. Used only by infrastructure elements.
  """
  updateClusterState(input: UpdateClusterState!): Cluster
}

enum OrderDirection {
  asc
  desc
}

type Organization {
  """The organization ID"""
  id: ID!

  """The organization's name"""
  name: String

  """
  A list of types applied to the organization, such
  as `Broadcaster` or `Agency`.
  """
  type: [String]

  """Applications belonging to the organization"""
  applications(offset: Int = 0, limit: Int = 30): ApplicationList

  """Freeform metadata in JSON format"""
  jsondata: JSON
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  seatLimit: Int

  """Organization's current status"""
  status: OrganizationStatus

  """Roles allowed within the organization"""
  roles: [Role]

  """Users belonging to the organization"""
  users(offset: Int = 0, limit: Int = 30): UserList

  """List of engines forbidden to this organization."""
  blacklist: EngineBlacklist

  """
  List of engines allowed for this organization.
  Takes precedence of the blacklist. That is, if a whitelist
  is defined, then only engines in the whitelist are permitted
  regardless of what is in the blacklist.
  This field is not fully implemented!
  """
  whitelist: EngineWhitelist

  """
  Custom schemas defined by this organization.
  This field is not fully implemented!
  """
  schemas: SchemaList

  """
  Watchlists for this organization.
  This field is not fully implemented!
  """
  watchlists: WatchlistList

  """Collections for this organization"""
  collections(
    """Provide a name to filter by collection name"""
    name: String

    """
    Provide an offset to skip to a certain element in the result, for paging.
    """
    offset: Int = 0

    """
    Specify maximum number of results to retrieve in this result. Page size.
    """
    limit: Int = 30
  ): CollectionList

  """Folder tree for this organization"""
  rootFolder(
    """Specify a root folder type to retrieve a specific root folder"""
    type: RootFolderType = watchlist
  ): Folder

  """Business unit"""
  businessUnit: String

  """Dashboards"""
  dashboards: [Dashboard]
  imageUrl: String

  """
  An ID corresponding to the organization used internally for some
  provisioning elements. `applicationId` on `TemporalDataObject`, `Job`,
  and some other types uses this value instead of the organization `id`.
  """
  internalApplicationId: ID

  """The number of active seats"""
  seats: Int
}

type OrganizationList implements Page {
  records: [Organization]

  """
  Provide an offset to skip to a certain element in the result, for paging.
  """
  offset: Int!

  """
  Maximum number of results that were retrieved in this query; page size
  """
  limit: Int!

  """Number of records returned in this response"""
  count: Int
}

enum OrganizationStatus {
  active
  deleted
}

enum OrganizationType {
  agency
  broadcaster
}

"""
Common fields used by queries and fields that support paging to represent
a single page of results.
"""
interface Page {
  """
  Provide an offset to skip to a certain element in the result, for paging.
  """
  offset: Int!

  """
  Maximum number of results that were retrieved in this query; page size
  """
  limit: Int!

  """Number of records returned in this response"""
  count: Int
}

type PasswordTokenInfo {
  passwordToken: String
}

input PauseCluster {
  id: ID!
}

input PauseClusterNode {
  """Node ID"""
  id: ID!
}

type Permission {
  id: ID!
  name: String
  description: String
}

type PermissionList implements Page {
  records: [Permission]

  """The starting index for records that were returned in this query."""
  offset: Int!

  """
  Maximum number of results that were retrieved in this query; page size
  """
  limit: Int!

  """Number of records returned in this response"""
  count: Int
}

input PollTask {
  id: ID!
  jobId: ID!
  pollPayload: JSON
}

type ProcessTemplate {
  id: ID!
  organizationId: ID!
  name: String!
  taskList: JSON!
}

type ProcessTemplateList implements Page {
  records: [ProcessTemplate!]
  offset: Int!
  limit: Int!
  count: Int
}

"""Metadata that represents a program."""
type Program implements Metadata {
  id: ID
  name: String!
  image: String
  liveImage: String
}

type ProgramAffiliate {
  sourceId: ID!
  source: Source
  scheduledJobId: ID!
  scheduledJob: ScheduledJob
  scheduledDay: DayOfWeek

  """The day of week adjusted to source live timezone"""
  scheduledDayLocal: DayOfWeek
  startDateTime: DateTime
  stopDateTime: DateTime
  startTime: Time
  stopTime: Time
  status: String
}

type ProgramAffiliateList implements Page {
  records: [ProgramAffiliate!]
  offset: Int!
  limit: Int!
  count: Int
}

"""
A property is a name-value pair. This is the base interface for properties.
"""
interface Property {
  name: String!
}

"""
Queries are used to retrieve data. If you're new to our API,
try the `me` query to explore the information you have access to.
Hit `ctrl-space` at any time to activate field completion hints, and
mouse over a field or parameter to see its documentation.
"""
type Query {
  """Retrieve a list of temporal data objects."""
  temporalDataObjects(
    """
    Application ID to get TDOs for. Defaults to the user's own application.
    """
    applicationId: ID

    """Provide an ID to retrieve a single specific TDO."""
    id: ID

    """
    Provide an offset to skip to a certain element in the result, for paging.
    """
    offset: Int = 0

    """
    Specify maximum number of results to retrieve in this result. Page size.
    """
    limit: Int = 30

    """
    Optionally, specify a source ID. TDOs ingested from this source will
    be returned.
    """
    sourceId: ID

    """
    Optionally, specify a scheduled job ID. TDOs ingested under this
    scheduled job will be returned.
    """
    scheduledJobId: ID

    """Whether to retrieve only tdos with the specified sampleMedia value"""
    sampleMedia: Boolean = false

    """
    Whether to retrieve public data that is not part of the user's organization.
    The default is false. Pass true to include public data in the result set.
    """
    includePublic: Boolean = false
    orderBy: TemporalDataObjectOrderBy = createdDateTime
    orderDirection: OrderDirection = desc

    """
    Provide optional filters against any date/time field to filter
    objects within a given time window.
    Matching objects must meet all of the given conditions.
    """
    dateTimeFilter: [TemporalDataObjectDateTimeFilter!]

    """Retrieve TDOs associated with the given mention"""
    mentionId: ID
  ): TDOList

  """Retrieve a single temporal data object"""
  temporalDataObject(
    """the TDO ID"""
    id: ID!
  ): TemporalDataObject

  """Retrieve a single Asset"""
  asset(
    """The asset ID"""
    id: ID!
  ): Asset

  """Retrieve a single Widget"""
  widget(
    """The widget ID"""
    id: ID!
    collectionId: ID!
    organizationId: ID!
  ): Widget

  """Retrieve clone job entries"""
  cloneRequests(
    """Provide an ID to retrieve a single specific clone request."""
    id: ID

    """
    Application ID to get clone requests for. Defaults to the user's own application.
    """
    applicationId: ID
    offset: Int = 0
    limit: Int = 30
  ): CloneRequestList

  """Retrieve engines"""
  engines(
    """Provide an ID to retrieve a single specific engine."""
    id: ID
    ids: [ID!]

    """Provide a category ID to filter by engine category."""
    categoryId: String

    """provide a category name or ID to filter by engine category"""
    category: String

    """Provide a list of states to filter by engine state."""
    state: [EngineState]

    """If true, return only engines owned by the user's organization."""
    owned: Boolean = false

    """If true, return only engines that require a library."""
    libraryRequired: Boolean

    """
    If true, return only engines that create their own TDO.
    If false, return only engines that do not create a TDO.
    If not set, return either.
    """
    createsTDO: Boolean

    """Provide a name, or part of a name, to search by engine name"""
    name: String

    """
    Specify maximum number of results to retrieve in this result. Page size.
    """
    offset: Int = 0

    """Specify maximum number of results to retrieve in this result."""
    limit: Int = 30

    """Filters for engine attributes"""
    filter: EngineFilter

    """Provide a list of EngineSortField to sort by."""
    orderBy: [EngineSortField]
  ): EngineList

  """Retrieve a single engine by ID"""
  engine(
    """Provide the engine ID"""
    id: ID!
  ): Engine
  engineBuild(
    """Provide the build ID"""
    id: ID!
  ): Build

  """Retrieve engine categories"""
  engineCategories(
    """Provide an ID to retrieve a single specific engine category."""
    id: ID

    """Provide a name, or part of one, to search by category name"""
    name: String

    """Return all categories of an engine type"""
    type: String

    """
    Specify maximum number of results to retrieve in this result. Page size.
    """
    offset: Int = 0

    """Specify maximum number of results to retrieve in this result."""
    limit: Int = 30
  ): EngineCategoryList

  """Retrieve a specific engine category"""
  engineCategory(
    """Supply the ID of the engine category to retrieve"""
    id: ID!
  ): EngineCategory

  """Retrieve jobs"""
  jobs(
    hasTargetTDO: Boolean

    """Provide an ID to retrieve a single specific job."""
    id: ID

    """Provide a list of status strings to filter by status"""
    status: [JobStatusFilter!]
    applicationStatus: String

    """
    Provide an offset to skip to a certain element in the result, for paging.
    """
    offset: Int = 0

    """
    Specify the maximum number of results to included in this response, or page size.
    """
    limit: Int = 30

    """
    Provide an application ID to filter jobs for a given application.
    Defaults to the user's own application.
    """
    applicationId: ID

    """
    Provide a target ID to get the set of jobs running against a particular TDO.
    """
    targetId: ID

    """Provide a cluster ID to get the jobs running on a specific cluster"""
    clusterId: ID

    """
    Provide a list of scheduled job IDs to get jobs associated with the scheduled jobs
    """
    scheduledJobIds: [ID!]

    """
    Return only jobs that are (true) or are not (false) associated with a scheduled job
    """
    hasScheduledJobId: Boolean

    """
    Provide sort information. The default is to sort by
    createdDateTime descending.
    """
    orderBy: [JobSortField!]

    """Filter by date/time field"""
    dateTimeFilter: [JobDateTimeFilter!]

    """
    Provide list of application IDs to filter jobs.
    Defaults to the user's own application.
    """
    applicationIds: [ID]

    """
    Provide a list of engine IDs to filter for jobs
    that contain tasks for the specified engines.
    """
    engineIds: [ID!]

    """
    Provide a list of engine category IDs to filter for jobs
    that contain tasks for engines in the specific categories.
    """
    engineCategoryIds: [ID!]
  ): JobList

  """Retrieve a single job"""
  job(
    """the job ID"""
    id: ID!
  ): Job

  """Retrieve a single task by ID"""
  task(
    """Provide the task ID."""
    id: ID!
  ): Task

  """Retrieve entity identifier types"""
  entityIdentifierTypes(
    """Provide an ID to retrieve a single specific entity identifier type."""
    id: ID

    """
    Provide an offset to skip to a certain element in the result, for paging.
    """
    offset: Int = 0

    """
    Specify maximum number of results to retrieve in this result. Page size.
    """
    limit: Int = 30
  ): EntityIdentifierTypeList
  entityIdentifierType(
    """Provide the entity identifier type ID"""
    id: ID!
  ): EntityIdentifierType

  """Retrieve all library types"""
  libraryTypes(
    """Provide an ID to retrieve a single specific library type."""
    id: ID

    """
    Provide an offset to skip to a certain element in the result, for paging.
    """
    offset: Int = 0

    """
    Specify maximum number of results to retrieve in this result. Page size.
    """
    limit: Int = 30
  ): LibraryTypeList

  """Retrieve a single library type"""
  libraryType(
    """Provide an ID to retrieve a single specific library type."""
    id: ID
  ): LibraryType

  """Retrieve libraries and entities"""
  libraries(
    """Provide an ID to retrieve a single specific library."""
    id: ID

    """Provide a name string to search by name."""
    name: String

    """
    Provide the name or ID of a library to search for libraries
    that contain that type.
    """
    type: String

    """
    Provide the id of an entity identifier type to search for libraries that correlate
    to that type.
    """
    entityIdentifierTypeIds: [String!]

    """
    Specify true if only libraries owned by the user's organization
    should be returned. Otherwise, shared libraries will be included.
    """
    includeOwnedOnly: Boolean = false

    """
    Provide an offset to skip to a certain element in the result, for paging.
    """
    offset: Int = 0

    """
    Specify maximum number of results to retrieve in this result. Page size.
    """
    limit: Int = 30

    """Specify a field to order by"""
    orderBy: LibraryOrderBy

    """Specify the direction to order by"""
    orderDirection: OrderDirection
  ): LibraryList

  """Retrieve a specific library"""
  library(
    """Provide a library ID."""
    id: ID!
  ): Library

  """Retrieve a specific library engine model"""
  libraryEngineModel(
    """Provide the library engine model ID"""
    id: ID!
  ): LibraryEngineModel

  """Retrieve a specific entity"""
  entity(
    """Provide an entity ID."""
    id: ID!
  ): Entity

  """Retrieve a list of entities across libraries"""
  entities(
    """Provide a list of entity IDs to retrieve those entities"""
    ids: [ID!]

    """
    Provide a list of library IDs to retrieve entities across
    multiple libraries.
    """
    libraryIds: [ID!]
    isPublished: Boolean
    identifierTypeId: ID
    name: String
    offset: Int = 0
    limit: Int = 30
    orderBy: LibraryEntityOrderBy
    orderDirection: OrderDirection
  ): EntityList

  """Retrieve library configuration"""
  libraryConfiguration(
    """Provide configuration id"""
    id: ID!
  ): LibraryConfiguration

  """
  Retrieve applications. These are custom applications integrated into
  the Veritone platform using the VDA framework.
  """
  applications(
    """Provide an ID to retrieve a single specific application."""
    id: ID

    """
    Provide a status, such as "draft" or "active"
    """
    status: ApplicationStatus

    """If true, return only applications owned by the user's organization."""
    owned: Boolean

    """
    Provide an offset to skip to a certain element in the result, for paging.
    """
    offset: Int = 0

    """
    Specify maximum number of results to retrieve in this result. Page size.
    """
    limit: Int = 30
  ): ApplicationList

  """Retrieve organizations"""
  organizations(
    """Provide an ID to retrieve a single specific organization."""
    id: ID

    """
    Provide an offset to skip to a certain element in the result, for paging.
    """
    offset: Int = 0

    """
    Specify maximum number of results to retrieve in this result. Page size.
    """
    limit: Int = 30

    """
    Provide a property from the organization kvp to filter the organizaion list.
    """
    kvpProperty: String

    """
    Provide value to for the kvpFeature filter.
    If not present the filter becomes kvpProperty existence filter
    """
    kvpValue: String
  ): OrganizationList

  """Retrieve a single organization"""
  organization(
    """
    The organization ID
    TODO take application ID as well as org ID
    """
    id: ID!
  ): Organization

  """Retrieve permissions"""
  permissions(
    """Provide an ID to retrieve a single specific permission."""
    id: ID
    name: String

    """
    Provide an offset to skip to a certain element in the result, for paging.
    """
    offset: Int = 0

    """
    Specify maximum number of results to retrieve in this result. Page size.
    """
    limit: Int = 30
  ): PermissionList

  """Retrieve users"""
  users(
    """
    Provide an ID to retrieve a single specific user.
    A user ID is a string in UUID format.
    """
    id: ID

    """Provide IDs to retrieve multiple users by ID."""
    ids: [ID]

    """Provide a name, or part of one, to search by name."""
    name: String

    """
    Provide a list of organization IDs to filter your search by organization.
    """
    organizationIds: [ID]

    """
    Provide an offset to skip to a certain element in the result, for paging.
    """
    offset: Int = 0

    """
    Specify maximum number of results to retrieve in this result. Page size.
    """
    limit: Int = 30

    """Include all organization users."""
    includeAllOrgUsers: Boolean
  ): UserList

  """Retrieve an individual user"""
  user(
    """
    The user ID.
    A user ID is a string in UUID format.
    """
    id: ID!
    organizationIds: [ID]
  ): User

  """Retrieve user's organization API tokens"""
  tokens: [Token]

  """Retrieve information for the current logged-in user"""
  me: User

  """Retrieve groups"""
  groups(
    """Provide an ID to retrieve a specific group by ID"""
    id: ID

    """Provide IDs to retrieve multiple groups by ID"""
    ids: [ID]

    """Provide a name, or part of one, to search for groups by name"""
    name: String

    """
    Provide a list of organization IDs to retrieve groups defined
    within certain organizations.
    """
    organizationIds: [ID]

    """
    Provide an offset to skip to a certain element in the result, for paging.
    """
    offset: Int = 0

    """
    Specify maximum number of results to retrieve in this result. Page size.
    """
    limit: Int = 30
  ): GroupList

  """Retrieve a single mention"""
  mention(
    """The mention ID"""
    mentionId: ID!

    """Comments pagination - limit"""
    limit: Int = 25

    """Comments pagination - limit"""
    offset: Int = 0

    """The user who owns the mention."""
    userId: String
  ): Mention

  """Retrieve a shared mention"""
  sharedMention(
    """share token"""
    shareId: ID!
  ): SharedMention

  """
  Search for mentions across an index.
  This query requires a user token.
  """
  searchMentions(
    """
    JSON structure containing the search query.
    TODO link to syntax documentation
    """
    search: JSON!
  ): SearchResult

  """
  Search for media across an index.
  This query requires a user token.
  """
  searchMedia(
    """
    JSON structure containing the search query.
    TODO link to syntax documentation
    """
    search: JSON!
  ): SearchResult

  """Retrieve the root folders for an organization"""
  rootFolders(
    """The type of root folder to retrieve"""
    type: RootFolderType
  ): [Folder]

  """Retrieve a single folder. Used to navigate the folder tree structure."""
  folder(
    """Provide an ID to retrieve a single specific user."""
    id: ID!
  ): Folder

  """Retrieve a single application"""
  application(
    """The application ID"""
    id: ID!
  ): Application

  """Retrieve a single ingestion configuration"""
  ingestionConfiguration(
    """The configuration ID"""
    id: ID!
  ): IngestionConfiguration

  """Retrieve ingestion configurations"""
  ingestionConfigurations(
    """Supply an ingestion configuration ID to retrieve a single Ingestion"""
    id: ID

    """Offset"""
    offset: Int = 0

    """Limit"""
    limit: Int = 30
    name: String
    startDate: DateTime
    endDate: DateTime

    """Specify one or more sources to filter by source type"""
    sources: [String!]

    """
    Supply an application ID to retrieve configurations only for
    that application.
    """
    applicationId: ID

    """Email address configured for ingestion"""
    emailAddress: String
  ): IngestionConfigurationList

  """Retrieve a list of schemas for structured data ingestions"""
  schemas(
    """Id of a schema to retrieve"""
    id: ID

    """Ids of schemas to retrieve"""
    ids: [ID!]

    """Specify the id of the DataRegistry to get schemas"""
    dataRegistryId: ID

    """Specify one or more statuses to filter by schema status"""
    status: [SchemaStatus!]

    """Specify a major version to filter schemas"""
    majorVersion: Int

    """Specify a data registry name to filter schemas"""
    name: String

    """The strategy used to find data registry name"""
    nameMatch: StringMatch = startsWith

    """Limit"""
    limit: Int = 30

    """Offset"""
    offset: Int = 0

    """Specify one or more fields and direction to order results"""
    orderBy: [SchemaOrder]
  ): SchemaList
  schema(id: ID!): Schema
  schemaProperties(
    dataRegistryVersion: [DataRegistryVersion!]
    search: String

    """Limit"""
    limit: Int = 30

    """Offset"""
    offset: Int = 0
  ): SchemaPropertyList

  """Retrieve a structured data object"""
  structuredData(
    """
    Supply the ID of the structured data object to retrieve. This will override filters.
    """
    id: ID!

    """Schema Id for the structured data object to retrieve"""
    schemaId: ID!
  ): StructuredData

  """Retrieve a structured data object"""
  structuredDataObject(
    """
    Supply the ID of the structured data object to retrieve. This will override filters.
    """
    id: ID!

    """Schema Id for the structured data object to retrieve"""
    schemaId: ID!
  ): StructuredData

  """Retrieve a paginated list of structured data object"""
  structuredDataObjects(
    """
    Supply the ID of the structured data object to retrieve. This will override filters.
    """
    id: ID

    """
    List of Ids of the structured data objects to retrieve. This will override filters.
    """
    ids: [ID!]

    """Schema Id for the structured data object to retrieve"""
    schemaId: ID!
    orderBy: [StructuredDataOrderBy!]
    limit: Int = 30
    offset: Int = 0
    owned: Boolean

    """
    Query to filter SDO. Supports operations such as and, or, eq, gt, lt, etc.
    TODO link to syntax documentation
    """
    filter: JSON
  ): StructuredDataList

  """
  Returns information about the GraphQL server, useful
  for diagnostics. This data is primarily used by Veritone
  development, and some fields may be restricted to Veritone administrators.
  """
  graphqlServiceInfo: GraphQLServiceInfo

  """
  Returns a signed writable S3 URL. A client can then
  upload to this URL with an HTTP PUT without providing
  any additional authorization (_note_: it must be a PUT.
  A POST will fail.)
  """
  getSignedWritableUrl(
    """
    Optional key of the object to generate a writable
    URL for. If not provided, a new, unique key will
    be generated. If a key is provided and resembles a file name
    (with extension delimited by .), a UUID will be inserted
    into the file name, leaving the extension intact.
    If a key is provided and does not resemble
    a file name, a UUID will be appended.
    """
    key: String
  ): WritableUrlInfo

  """
  Return writable storage URLs in bulk.
  A maximum of 1000 can be created in one call.
  See `getSignedWritableUrl` for details on usage of the
  response contents.
  """
  getSignedWritableUrls(
    """Number of signed URLs to return"""
    number: Int!
  ): [WritableUrlInfo!]!
  myRights: RightsListing

  """Retrieve the shared folders for an organization"""
  sharedFolders: [Folder]
  watchlists(id: ID, maxStopDateTime: DateTime, minStopDateTime: DateTime, minStartDateTime: DateTime, maxStartDateTime: DateTime, name: String, offset: Int = 0, limit: Int = 30, orderBy: WatchlistOrderBy = createdDateTime, orderDirection: OrderDirection = desc): WatchlistList
  watchlist(id: ID!): Watchlist
  mentionStatusOptions: [MentionStatus!]!
  dataRegistries(id: ID, name: String, nameMatch: StringMatch = startsWith, offset: Int = 0, limit: Int = 30, orderBy: DataRegistryOrderBy = createdDateTime, orderDirection: OrderDirection = desc, filterByOwnership: SchemaOwnership = all): DataRegistryList
  dataRegistry(id: ID!): DataRegistry
  subscription(id: ID!): Subscription!
  cognitiveSearch(id: ID!): CognitiveSearch!
  collections(id: ID, name: String, mentionId: ID, offset: Int = 0, limit: Int = 30): CollectionList!
  collection(id: ID!): Collection!
  mentions(
    id: ID

    """Get mentions created from the specified watchlist"""
    watchlistId: ID

    """Get mentions associated with the specified source"""
    sourceId: ID

    """Get mentions associated with sources of the specified source type"""
    sourceTypeId: ID

    """Get mentions associated directly with the specific TDO"""
    tdoId: ID

    """
    Specify date/time filters against mention fields.
    Querying for mentions can be expensive. If the query does not
    include a filter by `id`, `tdoId`, `sourceId`, `watchlistId`, or
    a user-provided `dateTimeFilter`, a default filter of the
    past 7 days is applied.
    """
    dateTimeFilter: [MentionDateTimeFilter!]

    """
    Set order information on the query. Multiple fields
    are supported.
    """
    orderBy: [MentionOrderBy!]
    offset: Int = 0
    limit: Int = 30
  ): MentionList

  """Retrieves engine results by TDO and engine ID or by job ID."""
  engineResults(
    """
    Provide the ID of the TDO containing engine results to retrieve.
    If this parameter is used, engineIds or engineCategoryIds must also be set.
    Results for _only_ the specified TDO will be returned.
    """
    tdoId: ID

    """
    Provide the ID of the Source containing engine results to retrieve.
    If this parameter is used, engineIds or engineCategoryIds must also be set.
    This takes priority over tdoId.
    """
    sourceId: ID

    """
    Provide one or more engine IDs to retrieve engine results by
    ID. This parameter is mandatory if tdoId is used, but optional
    if jobId or engineCategory is used.
    """
    engineIds: [ID!]

    """
    Provide one or more category IDs to get all results from that categroy.
    """
    engineCategoryIds: [ID!]

    """Provide a job ID to retrieve engine results for the job."""
    jobId: ID

    """Provide a mention ID to retrieve engine results for the mention."""
    mentionId: ID

    """Start offset ms for the results."""
    startOffsetMs: Int

    """End offset ms for the results."""
    stopOffsetMs: Int

    """Start date for the results. Takes priority over startOffsetMs."""
    startDate: DateTime

    """End date for the results. Takes priority over stopOffsetMs."""
    stopDate: DateTime

    """
    Whether or not to exclude user edited engine results. Defaults to false.
    """
    ignoreUserEdited: Boolean = false

    """
    A TDO ID can be provided for use if the provided `sourceId` and/or
    `mentionId` parameters do not resolve to a logical set of TDOs.
    Depending on parameter settings and available data,
    results from other TDOs can be included in the response.
    """
    fallbackTdoId: ID
  ): EngineResultList
  trigger(id: ID!): Trigger
  triggers: [Trigger]

  """
  Fetch all saved searches that the current user has made
  Fetch all saved searches that have been shared with
  the current users organization
  Include any saved searches that the user has created
  """
  savedSearches(offset: Int = 0, limit: Int = 30, includeShared: Boolean = false, filterByName: String, orderBy: SavedSearchOrderBy, orderDirection: OrderDirection): SavedSearchList!

  """Retrieve a list of export requests"""
  exportRequests(
    """Provide an ID to retrieve a single export request"""
    id: ID

    """
    Provide an offset to skip to a certain element in the result, for paging.
    """
    offset: Int = 0

    """
    Specify maximum number of results to retrieve in this result. Page size.
    """
    limit: Int = 30

    """Provide a list of status options to filter by status"""
    status: [ExportRequestStatus!]

    """
    Provide an event to retrieve export request. Should be 'exportRequest' or 'mentionExportRequest'
    Default value is 'exportRequest'
    """
    event: ExportRequestEvent = exportRequest
  ): ExportRequestList!
  exportRequest(
    id: ID!

    """
    Provide an event to retrieve export request. Should be 'exportRequest' or 'mentionExportRequest'
    Default value is 'exportRequest'
    """
    event: ExportRequestEvent = exportRequest
  ): ExportRequest!

  """Retrieve a event by id"""
  event(id: ID!): Event!

  """Retrieve a list of events by application"""
  events(
    """
    Provide an application to retrieve all its events.
    Use 'system' to list all public system events.
    """
    application: String!

    """
    Provide an offset to skip to a certain element in the result, for paging.
    """
    offset: Int = 0

    """
    Specify maximum number of results to retrieve in this result. Page size.
    """
    limit: Int = 30
  ): EventList!

  """
  This query returns information about time zones recognized by this
  server. The information is static and does not change.
  """
  timeZones: [TimeZone!]!

  """
  Examine entries from the audit log. All operations that modify data are
  written to the audit log. Only entries for the user's own organization
  can be queried.
  All queries are bracketed by a time window. A default time window is applied
  if the `toDateTime` and/or `fromDateTime` parameters are not provided.
  The maximum time window length is 30 days.
  Only Veritone and organization administrators can use this query.
  """
  auditLog(
    """
    Date/time up to which entries will be returned. In other words, the
    end of the query time window.
    Defaults to the current time.
    """
    toDateTime: DateTime

    """
    Date/time from which entries will be returned. In other words, the
    start of the query time window.
    Defaults to the `toDateTime` minus 7 days.
    """
    fromDateTime: DateTime

    """
    Organization ID to query records for. This value can only be used by
    Veritone administrators. Any value provided by user administrators will
    be ignored.
    """
    organizationId: ID

    """User name on audit entry. Must be exact match."""
    userName: String

    """
    IP address of the client that generated the audit action. Must be exact match.
    """
    clientIpAddress: String

    """
    HTTP user agent of the client that generated the audit action. Must be exact match.
    """
    clientUserAgent: String

    """
    The event type, such as `Create`, `Update`, or `Delete`.
    Must be exact match.
    """
    eventType: String

    """
    The ID of the object involved in the audit action. The format of this ID
    varies by object type. Must be exact match.
    """
    objectId: ID

    """
    The type of the object involved in the audit action, such as `Watchlist`
    or `TemporalDataObject`. Must be exact match.
    """
    objectType: String

    """Whether or not the action was successful."""
    success: Boolean

    """The unique ID of an audit log entry. Multiple values can be provided."""
    id: [ID!]

    """Offset into result set, for paging."""
    offset: Int = 0

    """
    Limit on result size, for paging (page size). Audit queries are
    lightweight so the default of 100 is higher than the default offset
    used elsewhere in the API.
    """
    limit: Int = 100

    """Order information. Default is order by `createdDateTime` descending."""
    orderBy: [AuditLogOrderBy!]
  ): AuditLogEntryList!

  """Get the media share by media shareId"""
  mediaShare(id: ID!): MediaShare!

  """Retrieve a shared collection"""
  sharedCollection(
    """share token"""
    shareId: ID!
  ): SharedCollection

  """Retrieve Veritone Workflow instance status by id"""
  workflowRuntime(workflowRuntimeId: ID!): WorkflowRuntimeResponse!

  """Get a specific workflowRuntimeData based on dataKey"""
  workflowRuntimeStorageData(
    """Unique id of the workflow instance"""
    workflowRuntimeId: ID!

    """The unique id to rertrieve a single workflow data"""
    storageKey: String

    """
    A prefix filter used to return a set of workflow data
    items whose dataKey starts with dataKeyPrefix
    """
    storageKeyPrefix: String

    """Offset for paging"""
    offset: Int = 0

    """
    Limit on result size, for paging (page size).
    workflowRuntimeData can be arbitrary large therefore smaller paging shoulf be preffered
    """
    limit: Int = 30
  ): WorkflowRuntimeStorageDataList!

  """Get list process templates by id or current organizationId"""
  processTemplates(id: ID, offset: Int = 0, limit: Int = 30): ProcessTemplateList!

  """Get process templates by id"""
  processTemplate(id: ID!): ProcessTemplate!

  """Get creative by id with current organizationId"""
  creative(id: ID!): Creative!

  """Retrieve a single schedule"""
  scheduledJob(id: ID!): ScheduledJob

  """Retrieve or search for schedules"""
  scheduledJobs(
    """Provide an ID to retrieve a specific schedule"""
    id: ID

    """
    Provide a schedule name, or part of one, to search for schedules
    by name. Supports prefix/like search.
    """
    name: String

    """Specify a run mode to filter to run mode"""
    runMode: RunMode

    """Specify isActive true or false to filter by active state"""
    isActive: Boolean
    engineId: ID
    engineCategoryId: ID
    engineType: [EngineTypeFilter!]

    """Specify an offset to retrieve additional pages"""
    offset: Int = 0

    """Specify a limit to limit result size."""
    limit: Int = 30
    dateTimeFilter: [ScheduledJobDateTimeFilter!]

    """Time filter is in station local time"""
    partTimeFilter: [ScheduledJobPartTimeFilter!]

    """
    Optionally, specify one or more source IDs. Scheduled jobs with
    any of the given sources as their primary source will be returned.
    """
    primarySourceId: [ID!]

    """
    Optionally, specify one or more source type IDs. Scheduled jobs with
    any of the given sources types on their primary source will be returned.
    """
    primarySourceTypeId: [ID!]
    hasJobTemplate: Boolean

    """
    Specify isRunning true or false to filter for scheduled jobs that
    have jobs running right now.
    """
    hasRunningJobs: Boolean

    """Order information. Default will order by modifiedDateTime descending."""
    orderBy: [ScheduledJobOrderBy!]

    """
    Specify a permission level to retrieve scheduled jobs to which you
    have at least that permission.
    """
    permission: ScheduledJobPermission = viewer

    """
    Specify clusterId to filter scheduled jobs that run on specified cluster
    """
    clusterId: ID
  ): ScheduledJobList

  """Retrieve a single engine configuration"""
  engineConfiguration(id: ID!): EngineConfiguration

  """Retrieve all engine configurations"""
  engineConfigurations(id: ID): EngineConfigurationList

  """Retrieve a single node"""
  clusterNode(id: ID!): ClusterNode!

  """Retrieve a list of nodes"""
  clusterNodes(id: ID, offset: Int = 0, limit: Int = 30): ClusterNodeList!

  """Retrieve a single cluster"""
  cluster(id: ID!): Cluster!

  """Retrieve a list of clusters"""
  clusters(
    id: ID
    name: String
    type: ClusterType
    offset: Int = 0
    limit: Int = 30

    """Type of string match to use against tags, if any"""
    tagMatch: StringMatch

    """List of tags to match against"""
    tags: [String!]
    dateTimeFilter: [ClusterDateTimeFilter!]
    orderBy: [ClusterOrderBy!]
  ): ClusterList!

  """Retrieve a single execution location"""
  executionLocation(id: ID!): ExecutionLocation!

  """Retrieve a list of execution locations"""
  executionLocations(id: ID): ExecutionLocationList!

  """Retrieve a single job template"""
  jobTemplate(id: ID!): JobTemplate!

  """Retrieve a list of job templates for a given job pipelineId"""
  jobTemplates(jobPipelineId: ID, scheduledJobId: ID, engineId: ID, engineType: [EngineTypeFilter!], offset: Int = 0, limit: Int = 30): JobTemplateList!

  """Retrieve a single task template"""
  taskTemplate(id: ID!): TaskTemplate!

  """Retrieve a single job pipeline"""
  jobPipeline(id: ID!): JobPipeline!

  """Retrieve a list of job pipelines owned by org"""
  jobPipelines(id: ID, scheduledJobId: ID, isPublic: Boolean, offset: Int = 0, limit: Int = 30): JobPipelineList!

  """Retrieve a single source"""
  source(id: ID!): Source!

  """Retrieve a list of sources"""
  sources(
    """Provide an ID to retrieve a specific source."""
    id: ID

    """Provide a source type ID to filter for sources of the specified type."""
    sourceTypeId: ID
    sourceTypeIds: [ID]

    """
    Provide a name or partial name value to filter by name.
    The `nameMatch` parameter can be used to determine the string
    match strategy used in the filter. Default is "starts with".
    Note that all matching is case-insensitive.
    """
    name: String

    """String matching strategy. Default is "starts with"."""
    nameMatch: StringMatch = startsWith

    """
    Provide an offset to skip to a certain element in the result, for paging.
    """
    offset: Int = 0

    """
    Specify maximum number of results to retrieve in this result. Page size.
    """
    limit: Int = 30

    """
    Set this flag to true or false to return only sources that do or do
    not have content templates associated with them.
    The default is neither (do not filter on the presence of content templates).
    """
    hasContentTemplates: Boolean

    """
    Set this flag to true to include public sources or false to include
    only sources owned by the
    user's org, not public sources.
    Public sources owned by the caller's org will always be returned.
    """
    includePublic: Boolean = true

    """
    Provide a correlation schama ID to filter for sources that correlate using specified schema.
    """
    correlationSchemaId: ID

    """
    Provide optional sort information. If not provided, a default sort
    by createdDateTime descending will be applied.
    """
    orderBy: [SourceSortField!]

    """
    Specify a permission level to retrieve sources to which you
    have at least that permission.
    """
    permission: SourcePermission = viewer
  ): SourceList!

  """Retrieve a single source type"""
  sourceType(id: ID!): SourceType!

  """Retrieve a list of source types"""
  sourceTypes(
    id: ID
    ids: [ID]

    """
    Provide a source type category ID to select source types belonging
    to the category
    """
    categoryId: ID

    """Provide `isLive` to select source types with the given value."""
    isLive: Boolean
    offset: Int = 0
    limit: Int = 30
  ): SourceTypeList!

  """Retrieve all source type categories"""
  sourceTypeCategories(
    """Optionally, provide a source category type ID."""
    id: ID
  ): SourceTypeCategoryList!

  """Retrieve a single source type category"""
  sourceTypeCategory(id: ID!): SourceTypeCategory!

  """Retrieve a single external credential"""
  externalCredential(id: ID!): ExternalCredential!

  """Retrieve a list of external credentials"""
  externalCredentials(id: ID): ExternalCredentialList!
  tasks(id: ID, taskTemplateId: ID): TaskList

  """matching cluster tags in use by this organization"""
  clusterTags(matchType: StringMatch = startsWith, match: String!): [String!]!
}

input ReplaceSavedSearch {
  id: ID!
  name: String!
  sharedWithOrganization: Boolean = false
  csp: JSON!
}

input RequestClone {
  sourceApplicationId: ID!
  destinationApplicationId: ID!
  cloneBlobs: Boolean = false
}

input RevertScheduledJob {
  id: ID!
}

type RightsListing {
  operations: [String!]!
  resources: JSON
}

"""A role signifies a user's permissions within a given context."""
type Role {
  description: String
  appName: String
  name: String!
  permissions: PermissionList
  id: ID!
}

enum RootFolderType {
  watchlist
  collection
  cms
}

enum RunMode {
  Continuous
  Recurring
  Once
  Now
}

type SavedSearch {
  id: ID!
  organizationId: ID!
  organization: Organization
  ownerId: ID!
  owner: User
  name: String!
  sharedWithOrganization: Boolean
  createdDateTime: DateTime!
  modifiedDateTime: DateTime!
  csp: JSON
}

type SavedSearchList implements Page {
  records: [SavedSearch!]
  count: Int
  offset: Int!
  limit: Int!
}

enum SavedSearchOrderBy {
  name
  createdDateTime
  sharedWithOrganization
}

type ScheduledJob {
  id: ID!
  organizationId: ID

  """Organization that owns this scheduled job"""
  organization: Organization
  name: String
  description: String
  startDateTime: DateTime
  stopDateTime: DateTime
  jobPipelineIds: [ID!]
  jobPipelines(offset: Int = 0, limit: Int = 30): JobPipelineList!
  jobTemplateIds: [ID!]
  jobTemplates(offset: Int = 0, limit: Int = 30): JobTemplateList!

  """
  Retrieve the complete set of job templates associated with this
  scheduled job, including those that are associated through a job
  pipeline.
  """
  allJobTemplates(offset: Int = 0, limit: Int = 30): JobTemplateList!

  """
  The ID of the primary source on this scheduled job, if applicable.
  This is based on the payloads of the tasks that are invoked for
  this scheduled job.
  """
  primarySourceId: ID

  """The primary source. See `primarySourceId` above."""
  primarySource: Source
  jobs(
    """Optionally, specify a TDO ID to filter by job target"""
    targetId: ID

    """Optionally, specify a cluster ID to filter by cluster"""
    clusterId: ID

    """
    Provide sort information. The default is to sort by
    createdDateTime descending.
    """
    orderBy: [JobSortField!]

    """
    Optionally, specify filters on date/time fields.
    If a filter is not provided here, the query will
    default to the past 3 months.
    """
    dateTimeFilter: [JobDateTimeFilter!]

    """Provide a list of status strings to filter by status"""
    status: [JobStatusFilter!]

    """
    Provide an offset to skip to a certain element in the result, for paging.
    """
    offset: Int = 0

    """
    Specify the maximum number of results to included in this response, or page size.
    """
    limit: Int = 30
  ): JobList!

  """
  Get a list of sources that are used
  by engine configurations that reference
  this schedule through the schedule -> job -> task relationship.
  """
  sources(offset: Int = 0, limit: Int = 30): SourceList
  parts: [SchedulePart!]
  isActive: Boolean!
  runMode: RunMode!
  details: JSON
  detailsSchemaId: ID
  createdDateTime: DateTime
  modifiedDateTime: DateTime

  """
  List of schema-controlled content templates attached
  to this scheduled job
  """
  contentTemplates: [ScheduledJobContentTemplate!]!

  """
  Permissions granted to other organizations. Only the source owner
  can view or edit this field.
  """
  collaborators: ScheduledJobCollaboratorList!

  """
  A public scheduled job can be viewed and launched by
  users from any organization. By default, scheduled jobs are
  private and can only be viewed or launched by the owning organization
  and organizations that the owner has explicitly shared them with.
  Only Veritone administrators can create public scheduled jobs.
  """
  isPublic: Boolean

  """The user's permission on this scheduled job"""
  permission: ScheduledJobPermission
  primarySourceTypeId: ID
  primarySourceType: SourceType
  ingestionStatusId: ID
  ingestionStatus: String
  affiliates: ProgramAffiliateList!
}

"""
A source ACL grants a single organization limited rights to a private source
"""
type ScheduledJobCollaborator {
  """The permission granted. Either `viewer` or `editor`."""
  permission: ScheduledJobPermission!

  """Organization ID the source was shared with"""
  organizationId: ID!

  """The organization the source was shared with"""
  organization: Organization
}

type ScheduledJobCollaboratorList implements Page {
  records: [ScheduledJobCollaborator!]!
  offset: Int!
  limit: Int!
  count: Int
}

type ScheduledJobContentTemplate {
  id: ID!
  scheduledJobId: ID!
  sdoId: ID!
  sdo: StructuredData
  schemaId: ID!
  data: JSON
  createdDateTime: DateTime
  modifiedDateTime: DateTime
}

enum ScheduledJobDateTimeField {
  startDateTime
  stopDateTime
  dateCreated
  dateModified
}

input ScheduledJobDateTimeFilter {
  toDateTime: DateTime
  fromDateTime: DateTime
  field: ScheduledJobDateTimeField!
  includeEmpty: Boolean
}

type ScheduledJobList implements Page {
  records: [ScheduledJob!]!
  count: Int!
  offset: Int!
  limit: Int!
}

input ScheduledJobOrderBy {
  field: ScheduledJobOrderField!
  direction: OrderDirection = desc
}

enum ScheduledJobOrderField {
  id
  createdDateTime
  modifiedDateTime
  startDateTime
  stopDateTime
  name
  runMode
  isActive
}

enum ScheduledJobPartTimeField {
  startTime
  endTime
}

input ScheduledJobPartTimeFilter {
  toTime: Time
  fromTime: Time
  field: ScheduledJobPartTimeField!
}

"""Permissions or roles on source objects"""
enum ScheduledJobPermission {
  """
  A source editor can make updates to some source fields, but cannot
  delete or share the source.
  """
  editor

  """
  A viewer can view the source and use it in ingestion jobs,
  but not make any updates to it.
  """
  viewer

  """A source owner has full rights to update and delete the source."""
  owner
}

type SchedulePart {
  scheduleType: ScheduleType!

  """The day of week adjusted to source live timezone"""
  scheduledDayLocal: DayOfWeek
  scheduledDay: DayOfWeek
  startTime: Time
  stopTime: Time
  repeatIntervalUnit: IntervalUnit
  repeatInterval: Int
  durationSeconds: Int
}

enum ScheduleType {
  Weekly
  Interval
}

type Schema {
  id: ID!
  dataRegistryId: ID!
  dataRegistry: DataRegistry
  definition: JSON
  majorVersion: Int!
  minorVersion: Int!
  createdBy: User
  modifiedBy: User
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  status: SchemaStatus

  """List of status the Schema can transition to."""
  validActions: [SchemaAction]

  """SDOs under this schema"""
  structuredDataObjects(offset: Int = 0, limit: Int = 30): StructuredDataList

  """The organization that owns this schema."""
  organization: Organization

  """The Id of the organization that owns this schema."""
  organizationId: ID
}

enum SchemaAction {
  view
  edit
  publish
  deactivate
  delete
}

type SchemaList implements Page {
  records: [Schema]

  """The starting index for records that were returned in this query."""
  offset: Int!

  """
  Maximum number of results that were retrieved in this query; page size
  """
  limit: Int!

  """Number of records returned in this response"""
  count: Int
}

input SchemaOrder {
  field: SchemaOrderFields!
  direction: OrderDirection = desc
}

enum SchemaOrderFields {
  majorVersion
  minorVersion
  status
  createdDateTime
  modifiedDateTime
}

enum SchemaOwnership {
  mine
  others
  all
}

type SchemaProperty {
  dataRegistryId: ID!
  majorVersion: Int!
  schema: Schema!
  path: String!
  searchPath: String!
  type: String!
  title: String
}

type SchemaPropertyList implements Page {
  records: [SchemaProperty]

  """The starting index for records that were returned in this query."""
  offset: Int!

  """
  Maximum number of results that were retrieved in this query; page size
  """
  limit: Int!

  """Number of records returned in this response"""
  count: Int
}

enum SchemaStatus {
  published
  deleted
  draft
  inactive
}

enum ScopeRequirement {
  Any
  All
}

type SearchFieldConfig {
  searchField: String
  indexField: String
}

enum SearchIndex {
  mine
  global
}

input SearchInput {
  """
  Provide an offset to skip to a certain element in the result, for paging.
  """
  offset: Int = 0

  """
  Maximum number of results that were retrieved in this query; page size
  """
  limit: Int = 0
  index: [String]!
  query: JSON!
  select: JSON
}

"""
Results from a mention or media search.
TODO link to format documentation for core-search-server
"""
type SearchResult {
  jsondata: JSON!
}

"""Contains security settings on an asset container"""
type Security {
  """Whether or not the object is globally visible"""
  global: Boolean
}

input SendEmail {
  from: String!
  to: String!
  subject: String!

  """Message can be either text or HTML"""
  message: String!
  replyTo: String!
}

"""Input type for AssetFileData"""
input SetAssetFileData {
  """The MD5 checksum of the file"""
  md5sum: String

  """The file size in bytes"""
  size: Int

  """Original file URI, if provided on asset creation"""
  originalFileUri: String

  """The insertion mode of the asset"""
  mode: AssetCreationMode = create
}

"""Input type for AssetSourceData"""
input SetAssetSourceData {
  """The name of the asset source engine or engine category"""
  name: String

  """ID of the specific task that created the asset"""
  taskId: ID

  """ID of the engine that created the asset"""
  engineId: ID

  """
  Optional ID of the source from which this asset
  was created. This field will typically be set only
  by adapters that ingest data.
  """
  sourceId: ID

  """Optional ID of the scheduled job that created this asset"""
  scheduledJobId: ID

  """
  Optional ID of the asset this asset was created from.
  This will usually be assets with edits to a previous
  asset.
  """
  assetId: ID
}

enum SetClusterPermission {
  viewer
  none
}

input SetEngineBlacklist {
  """
  Provide the organization ID to update. This field is required only
  when using addToEngineBlacklist or deleteFromEngineBlacklist.
  """
  organizationId: ID

  """Provide the IDs of engines to set."""
  engineIds: [ID!]

  """Provide the IDs of engine categories to set."""
  engineCategoryIds: [ID!]
}

input SetEngineWhitelist {
  """
  Provide the organization ID to update. This field is required only
  when using addToEngineWhitelist or deleteFromEngineWhitelist.
  """
  organizationId: ID
  engineIds: [ID!]
}

"""
Settings that determine when to set a new entity identifier
as the entity profile image.
"""
enum SetEntityProfileImage {
  """Do not update the entity profile image"""
  none

  """
  Set the the entity identifier URL as the entity profile image
  only if there is no current profile image. Will cause an error
  if the entity identifier type is not an image.
  """
  ifNotSet

  """
  Set the entity identifier as the new entity profile image,
  overwriting whatever value is present. Will cause an error
  if the entity identifier type is not an image.
  """
  always
}

"""
Input used to set the primary asset of a given type on a TDO.
The type must be supported by the server; primary asset is used
by certain engines and front end components.
Currently "media" and "transcript" are supported.
"""
input SetPrimaryAsset {
  """ID of the asset"""
  id: ID!

  """
  The asset type -- "media" or "transcript"
  """
  assetType: String!
}

enum SetScheduledJobPermission {
  viewer
  editor
  none
}

enum SetSourcePermission {
  viewer
  editor
  none
}

"""Identifies the task that created a TDO."""
input SetTDOSourceData {
  """ID of the task that created this TDO"""
  taskId: ID

  """
  Optional ID of the source from which this TDO's initial
  data was created. This field will typically be set only
  by adapters that ingest data and create TDOs.
  """
  sourceId: ID

  """Optional ID of the scheduled job that created this TDO."""
  scheduledJobId: ID
}

type Share {
  id: ID!
  recipients: [String]
  shareMessage: String
  shareOptionsJson: JSON
  folderId: ID
  mentionId: ID
  mediaShare: MediaShareInfo
}

input ShareCollection {
  """id of the collection"""
  folderId: ID!

  """message in email"""
  shareMessage: String

  """list of recipients"""
  recipients: [String]

  """collection specific share options"""
  shareOptions: ShareOptions
}

type SharedCollection {
  name: String
  image: String
  folderId: ID
  folderTypeId: ID
  organizationId: ID
  programCount: Int
  shareInfo: Share
  mentions: SharedMentionList
}

type SharedMention {
  id: ID!
  organizationId: ID!
  sourceTypeId: ID
  sourceId: ID
  scheduledJobId: ID
  mediaId: ID
  advertiserId: ID
  brandId: ID
  campaignId: ID
  watchlistId: ID
  statusId: ID
  complianceStatusId: ID
  spotTypeId: ID
  audienceMarketCount: Int
  audienceAffiliateCount: Int
  mentionHitCount: Int
  audience: Int
  mentionRating: Int
  isMatch: Boolean
  mentionDate: DateTime
  metadata: JSON
  mentionSnippets: [MentionSnippets]
  userSnippets: [MentionUserSnippets]
  adCreative: JSON
  fingerprint: JSON
  cognitiveEngineResults: JSON
  comments: [MentionComment]
  hash: ID
  hitStartDateTime: DateTime
  hitEndDateTime: DateTime
  organization: JSON
  temporalDataObject: JSON
  scheduledJob: JSON
  share: Share
  watchlist: JSON
}

type SharedMentionList implements Page {
  records: [SharedMention]

  """The starting index for records that were returned in this query."""
  offset: Int!
  limit: Int!

  """Number of records returned in this response"""
  count: Int
}

type SharedWith {
  """List of organizationIds that have read access to this object"""
  read: [Int]

  """List of organizationIds that have write access to this object"""
  write: [Int]
}

input ShareFolderInput {
  """The treeObjectId of the Folder to share"""
  treeObjectId: ID!

  """The organizations that will have read permissions to the Folder"""
  readOrganizationIds: [Int]

  """The organizations that will have write permissions to the Folder"""
  writeOrganizationIds: [Int]
}

input ShareMention {
  """id of the mention"""
  mentionId: ID!

  """message in email"""
  shareMessage: String

  """list of recipients"""
  recipients: [String]

  """app specific share options"""
  shareOptions: JSON

  """Internal API token can create shared mention for other orgs"""
  organizationId: ID

  """UserID the shared mention is being created for"""
  userId: ID
}

input ShareMentionFromCollection {
  """id of the mention from collection"""
  mentionId: ID!

  """id of the collection"""
  folderId: ID!

  """message in email"""
  shareMessage: String

  """list of recipients"""
  recipients: [String]

  """Collection image"""
  shareOptions: ShareOptions
}

input ShareMentionInBulk {
  """Array ids of the mentions"""
  mentionIds: [ID!]!

  """message in email"""
  shareMessage: String

  """list of recipients"""
  recipients: [String]

  """Collection image"""
  shareOptions: JSON
}

input ShareOptions {
  showImage: Boolean
  showComments: Boolean
  showRating: Boolean
  showHeader: Boolean
  showOrganizationLogo: Boolean
  organizationLogoUrl: Boolean
  showEngineResults: Boolean
  showHits: Boolean
  showAffiliateStripdown: Boolean
  showDownload: Boolean
  showDescription: Boolean
  mentionPrePaddingSeconds: Float
  mentionPostPaddingSeconds: Float
}

"""
A source represents a source of data and is used by adapters to ingest
data into the platform for use by an engine workflow.
"""
type Source {
  """Unique ID of this source"""
  id: ID!

  """ID of the source type for this source."""
  sourceTypeId: ID!

  """The source type for this source"""
  sourceType: SourceType

  """A name for this source"""
  name: String!

  """
  Metadata associated with this source. The schema for this data is
  specific to the source type and controlled by a schema.
  """
  details: JSON

  """
  Indicates whether this source is public and available to all organizations
  or restricted to the organization that owns id.
  """
  isPublic: Boolean!

  """ID of the organization that owns this source"""
  organizationId: ID!

  """The organization that owns this source"""
  organization: Organization

  """Date and time this source was created"""
  createdDateTime: DateTime

  """Date and time this source was last modified"""
  modifiedDateTime: DateTime

  """An optional thumbnail image URL for the source"""
  thumbnailUrl: String
  contentTemplates: [SourceContentTemplate!]!

  """Id of a published data registry schema"""
  correlationSchemaId: ID

  """Id of a structured data object for the correlationSchemaId"""
  correlationSDOId: ID

  """permission the currently authenticated principal has on this source."""
  permission: SourcePermission!

  """
  Permissions granted to other organizations. Only the source owner
  can view or edit this field.
  """
  collaborators(orderBy: SourceCollaboratorOrderBy = organizationId, orderDirection: OrderDirection = asc): SourceCollaboratorList!

  """
  Current state for the source object. This is controlled by
  the adapters that use the source and should not be set by
  other clients.
  """
  state: JSON
}

"""
A source ACL grants a single organization limited rights to a private source
"""
type SourceCollaborator {
  """The permission granted. Either `viewer` or `editor`."""
  permission: SourcePermission!

  """Organization ID the source was shared with"""
  organizationId: ID!

  """The organization the source was shared with"""
  organization: Organization
}

type SourceCollaboratorList implements Page {
  records: [SourceCollaborator!]!
  offset: Int!
  limit: Int!
  count: Int
}

enum SourceCollaboratorOrderBy {
  organizationId
  permission
}

type SourceContentTemplate {
  id: ID!
  sourceId: ID!
  sdoId: ID!
  sdo: StructuredData
  schemaId: ID!
  data: JSON
  createdDateTime: DateTime
  modifiedDateTime: DateTime
}

type SourceList implements Page {
  records: [Source!]!
  count: Int!
  offset: Int!
  limit: Int!
}

"""Source list sort field options"""
enum SourceOrderField {
  createdDateTime
  modifiedDateTime
  id
  name
  sourceTypeId
}

"""Permissions or roles on source objects"""
enum SourcePermission {
  """
  A source editor can make updates to some source fields, but cannot
  delete or share the source.
  """
  editor

  """
  A viewer can view the source and use it in ingestion jobs,
  but not make any updates to it.
  """
  viewer

  """A source owner has full rights to update and delete the source."""
  owner
}

"""Source list sort information"""
input SourceSortField {
  """Specify the field to sort by. Required."""
  field: SourceOrderField!

  """Specify the sort direction. Default is descending."""
  direction: OrderDirection = desc
}

"""
A source type represents a category of sources that share common
attributes, such as "TV station" or "Real-time camera feed".
"""
type SourceType {
  """Unique ID of this source type"""
  id: ID!

  """A name for this source type"""
  name: String!
  organizationId: ID
  isPublic: Boolean

  """
  The ID of an optional schema for instances (sources) of
  this source type
  """
  sourceSchemaId: ID

  """The icon representing the type of source"""
  iconClass: String

  """
  The schema object used to validate details for instances (sources)
  of this source type
  """
  sourceSchema: Schema

  """
  The ID of an optional schema for credentials associated with
  sources of this type.
  """
  credentialSchemaId: ID

  """
  The schema used to validate credentials associated with sources
  of this type.
  """
  credentialSchema: Schema

  """Date and time this object was created."""
  createdDateTime: DateTime

  """Date and time this object was last modified"""
  modifiedDateTime: DateTime
  credentialType: CredentialType

  """Indicates whether or not the source is "live", such as a camera feed"""
  isLive: Boolean

  """Indicates whether the source requires a scan job pipeline"""
  requiresScanPipeline: Boolean
  supportedRunModes: [RunMode!]!

  """
  The source type category ID for this source type.
  Used primarily by Veritone platform components.
  """
  categoryId: ID!

  """
  The source type category for this source type.
  Used primarily by Veritone platform components.
  """
  category: SourceTypeCategory!

  """
  List of source formats applicable to this source type.
  Only applies to certain source types; many will have an
  empty list.
  """
  sourceFormats: [String!]!

  """
  List of program formats applicable to this source type.
  Only applies to certain source types; many will have an
  empty list.
  """
  programFormats: [String!]!

  """Sources created under this source type"""
  sources(
    """Optionally, provide a list of IDs to retrieve sources by ID"""
    id: [ID!]

    """
    Provide a name or partial name value to filter by name.
    The `nameMatch` parameter can be used to determine the string
    match strategy used in the filter. Default is "starts with".
    Note that all matching is case-insensitive.
    """
    name: String

    """String matching strategy. Default is "starts with"."""
    nameMatch: StringMatch = startsWith

    """
    Provide an offset to skip to a certain element in the result, for paging.
    """
    offset: Int = 0

    """
    Specify maximum number of results to retrieve in this result. Page size.
    """
    limit: Int = 30

    """
    Set this flag to true or false to return only sources that do or do
    not have content templates associated with them.
    The default is neither (do not filter on the presence of content templates).
    """
    hasContentTemplates: Boolean

    """
    Set this flag to true to include public sources or false to include
    only sources owned by the
    user's org, not public sources.
    Public sources owned by the caller's org will always be returned.
    """
    includePublic: Boolean = true

    """
    Provide a correlation schama ID to filter for sources that correlate using specified schema.
    """
    correlationSchemaId: ID

    """
    Provide optional sort information. If not provided, a default sort
    by createdDateTime descending will be applied.
    """
    orderBy: [SourceSortField!]
  ): SourceList!
}

"""Source type categories are managed by Veritone."""
type SourceTypeCategory {
  id: ID!
  name: String!
}

type SourceTypeCategoryList implements Page {
  records: [SourceTypeCategory!]!
  limit: Int!
  offset: Int!
  count: Int
}

type SourceTypeList implements Page {
  records: [SourceType!]!
  count: Int!
  offset: Int!
  limit: Int!
}

"""Used to control string matching on fields that support it"""
enum StringMatch {
  """
  Match if the target string field starts with the supplied value.
  Case-insensitive.
  """
  startsWith

  """
  Match if the target string field ends with the supplied value.
  Case-insensive.
  """
  endsWith

  """
  Match if the target string field contains the supplied value
  anywhere in its content. Use only when strictly necessary, as
  startsWith and endsWith offer better performance.
  Case-insensitive.
  """
  contains

  """
  Match if the target string field exactly matches the
  supplied value. Case-insensitive.
  """
  exact
}

"""Type representing a string property"""
type StringProperty implements Property {
  name: String!
  value: String
}

type StructuredData {
  """The ID"""
  id: ID!

  """Id of the schema used to validate this object"""
  schemaId: ID!

  """The schema used to validate this object"""
  schema: Schema
  data(
    """
    Optionally, specify a path into the JSON data.
    Only the value of the path will be returned, at the
    top level. The value will be empty if there is nothing
    in the JSON at that path.
    This parameter is useful for directly addressing fields in the JSON.
    """
    path: String
  ): JSON
  dataString(indent: Int = 0): String
  createdDateTime: DateTime
  modifiedDateTime: DateTime
}

type StructuredDataList implements Page {
  records: [StructuredData]
  count: Int
  offset: Int!
  limit: Int!
  owned: Boolean
  orderBy: [StructuredDataOrderByType!]
}

input StructuredDataOrderBy {
  field: StructuredDataOrderByField!
  direction: OrderDirection = desc
}

enum StructuredDataOrderByField {
  createdDateTime
  modifiedDateTime
}

type StructuredDataOrderByType {
  field: StructuredDataOrderByField!
  direction: OrderDirection!
}

"""
An object containing custom structured data.
This type is not fully implemented.
"""
type StructuredJSONObject implements Metadata {
  data: JSON
  schema: StructuredJSONSchema!
  name: String!
  id: ID!
}

"""
A custom structured data schema, specified in JSON.
This type is not fully implemented.
"""
type StructuredJSONSchema {
  schema: JSON
  name: String!
  id: ID!
  ownerOrganizationId: ID!
  organization: Organization!
}

input SubscribeEvent {
  """Existing event name"""
  eventName: String

  """Existing event type"""
  eventType: String

  """Identifier of the app using the event"""
  application: String!

  """
  a string payload, it should be serialized Protobuf data with base64 encoding
  """
  delivery: EventDelivery!
}

type Subscription {
  id: ID!
  organizationId: ID!
  objectType: SubscriptionObjectType!
  frequency: SubscriptionFrequency!
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  isActive: Boolean!

  """
  The ID of the object on which this subscription is set,
  such as a watchlist ID.
  """
  targetId: ID!

  """Scheduled time of day"""
  scheduledTime: Time

  """Time zone of the scheduled time"""
  scheduledTimeZone: String

  """Scheduled day of the week"""
  scheduledDay: DayOfWeek
  jsondata: JSON
  contact: SubscriptionContact!
  unsubscribeHash: String
}

type SubscriptionContact {
  userId: ID!
  emailAddress: String
  phoneNumber: String
  webhookUri: String
}

enum SubscriptionFrequency {
  immediate
  daily
  weekly
  never
}

enum SubscriptionObjectType {
  mention
}

enum SupportedGPU {
  G2
  G3
  P2
}

type SystemEventInfo {
  topic: String!
  payload: JSON!
  timestamp: DateTime!
  id: ID!
}

"""Represents a single engine task"""
type Task {
  """The task ID"""
  id: ID!
  name: String
  description: String

  """Date and time the task was created"""
  createdDateTime: DateTime

  """Date and time the task was last modified"""
  modifiedDateTime: DateTime
  createdBy: String
  modifiedBy: String

  """Date and time the task was queued for execution."""
  queuedDateTime: DateTime

  """Date and time the task completed."""
  completedDateTime: DateTime

  """Date and time task execution started"""
  startedDateTime: DateTime

  """The task status. See TaskStatus enum for details."""
  status: TaskStatus

  """
  Optional order in which the task should run, relative to other tasks
  in the job that contains it.
  """
  order: Int

  """Whether or not the task is run on the clone of a TDO"""
  isClone: Boolean

  """Application ID that owns the task"""
  applicationId: String

  """
  The ID of the TemporalDataObject the task
  was created for.
  """
  targetId: ID

  """The TemporalDataObject the task was created for."""
  target: TemporalDataObject

  """ID of the engine for the task."""
  engineId: ID

  """The engine for the task"""
  engine: Engine

  """The ID of the job that contains this task"""
  jobId: ID

  """The job that contains this task."""
  job: Job

  """ID of the engine build used for this task."""
  buildId: ID

  """The engine build used for this task"""
  build: Build

  """The source asset for this task, if there is one."""
  sourceAsset: Asset

  """The ID of the source asset for this task, if there is one."""
  sourceAssetId: ID
  mediaLengthSec: Int
  mediaStorageBytes: Int
  mediaFileName: String

  """The incoming task payload, in JSON format"""
  payload: JSON

  """The task output, in JSON format."""
  output: JSON

  """The incoming task payload, in String format."""
  payloadString: String

  """The task output, in String format."""
  outputString: String

  """The log file produced during task execution"""
  log: TaskLog

  """For backwards compatibility only"""
  taskPayload: JSON

  """For backwards compatibility only"""
  taskOutput: JSON

  """True if this task was created as a test task"""
  testTask: Boolean
  parentTaskId: ID
  parentTask: Task
  childTaskIds: [ID!]
  childTasks: [Task!]

  """A standby task that will execute if this one fails."""
  standbyTask: Task

  """
  The task that this task is a standby for. If the task
  identified in this field fails, the current task will execute.
  """
  standbyForTask: Task

  """
  Contains metadata used by the platform run-time system to execute
  the task. This field is accessible only to platform components.
  """
  runtimePayload: JSON

  """
  Failure reason code. This will be set only if the task final status
  was `failed`.
  """
  failureReason: TaskFailureReason

  """
  Failure message from the engine. This will be set only if the task final
  status was `failed` and `failureReason` is set.
  """
  failureMessage: String
  engineConfiguration: EngineConfiguration
  engineConfigurationId: ID
  executionLocation: ExecutionLocation
  executionLocationId: ID
  templateId: ID
  template: TaskTemplate
}

enum TaskDateTimeField {
  createdDateTime
  modifiedDateTime
}

input TaskDateTimeFilter {
  toDateTime: DateTime
  fromDateTime: DateTime
  field: TaskDateTimeField!
}

enum TaskFailureReason {
  """The engine encountered an unexpected internal error."""
  internal_error

  """The cause of the failure could not be determined."""
  unknown

  """
  The engine attempted to download
  content from a URL provided in the task payload and
  received a 404.
  """
  url_not_found

  """
  The engine attempted to download
  content from a URL provided in the task payload and
  received a 401 or 403.
  """
  url_not_allowed

  """
  The engine attempted to download
  content from a URL provided in the task payload and
  the download timed out
  """
  url_timeout

  """
  The engine attempted to download
  content from a URL provided in the task payload and
  the connection was refused.
  """
  url_connection_refused

  """
  The engine attempted to download content from a URL
  provided in the task payload an received an error.
  """
  url_error

  """
  The input to the engine was incompatible with the engine
  requirements. For example, an input media file had an
  unsupported MIME type or the file was empty.
  """
  invalid_data

  """An engine operation was subject to rate limiting."""
  rate_limited

  """The engine received an authorization error from the Veritone API."""
  api_not_allowed

  """
  The engine received an authentication error from the Veritone API using
  the token provided in the task payload.
  """
  api_authentication_error

  """
  The engine received a "not found" error from the Veritone API on
  a required object.
  """
  api_not_found

  """
  An unexpected error was received from the Veritone API, such as
  HTTP 500, HTTP 502, or an `internal_error` error.
  """
  api_error

  """
  The engine could not write temporary files to disk for processing
  due to disk space full or other system error.
  """
  file_write_error

  """
  The engine encountered a missing binary dependency or configuration,
  such as a missing executable or package or incompatible hardware.
  """
  system_dependency_missing

  """
  The engine encountered an operating system, hardware, or other
  system-level error.
  """
  system_error

  """
  The error cause is known, but could not be mapped to a `TaskFailureReason`
  value. The `failureMessage` input field should contain details.
  """
  other
}

type TaskList implements Page {
  records: [Task]

  """The starting index for records that were returned in this query."""
  offset: Int!
  limit: Int!

  """Number of records returned in this response"""
  count: Int
}

type TaskLog {
  """URI to the task log file"""
  uri: String

  """
  The entire text contents of the log file. Note that this value can long.
  """
  text: String

  """
  The log file in JSON form. If the log file contains valid JSON,
  this field will contain the native structure. If the log file does not
  contain valid JSON, this field will contain a single property called
  `text` with a string value containing the entire log file.
  """
  jsondata: JSON
}

enum TaskStatus {
  pending
  running
  complete
  queued
  accepted
  failed
  cancelled
  standby_pending
  waiting
  resuming
  aborted
}

type TaskTemplate {
  id: ID!
  engineId: ID
  engine: Engine
  engineConfigId: ID
  engineConfig: EngineConfiguration
  executionLocationId: ID
  executionLocation: ExecutionLocation
  jobTemplateId: ID
  jobTemplate: JobTemplate
  payload: JSON
  payloadString: String
  parentTaskId: ID
  parentTask: Task
  childTaskIds: [ID!]!
  childTasks: TaskTemplateList!
}

type TaskTemplateList implements Page {
  records: [TaskTemplate!]!
  count: Int!
  offset: Int!
  limit: Int!
}

"""
Options used by the cleanupTDO mutation to select which data is deleted.
"""
enum TDOCleanupOption {
  """
  Indicates that all assets should be deleted from storage, including
  those used to store engine results. Metadata about the assets will remain
  until the container TemporalDataObject is permanently deleted.
  """
  storage

  """
  Indicates that all search index data should be deleted. The TemporalDataObject
  and its assets will no longer be accessible through search.
  """
  searchIndex

  """
  Indicates that engine results stored on related task objects should be deleted.
  Engine results stored as assets will remain until assets are removed
  using the storage option.
  """
  engineResults
}

type TDOList implements Page {
  records: [TemporalDataObject]

  """The starting index for records that were returned in this query."""
  offset: Int!

  """
  Maximum number of results that were retrieved in this query; page size
  """
  limit: Int!

  """Number of records returned in this response"""
  count: Int
}

"""
Describes source information about a TDO. That is,
the components and processes that produced it.
Each field may or may not have a value, depending on
how the TDO was created.
"""
type TDOSourceData {
  """Task ID, typically of an ingestion task."""
  taskId: ID

  """The task object."""
  task: Task

  """Ingestion source ID"""
  sourceId: ID

  """ID of the scheduled job, if any, under which this TDO was created"""
  scheduledJobId: ID

  """ID of the engine used in the task that created this TDO"""
  engineId: ID

  """The engine used in the task that created this TDO."""
  engine: Engine

  """The scheduled job under which this TDO was created, if any"""
  scheduledJob: ScheduledJob

  """The source from which this TDO was created, if any"""
  source: Source
}

"""Describes a stream that is available on a TDO"""
type TDOStreamData {
  """The stream URI"""
  uri: String!

  """
  The protocol, such as "dash" or "hls"
  """
  protocol: String!
}

type TDOStreamManifest {
  segments: [JSON!]
  initSegment: JSON
}

type TemporalDataObject {
  """
  Object creation timestamp. Does not change. In seconds since epoch (TODO change!).
  """
  createdDateTime: DateTime

  """Object modification timestamp. In seconds since epoch (TODO change!)."""
  modifiedDateTime: DateTime

  """The object's unique ID"""
  id: ID!
  createdBy: String
  modifiedBy: String
  description: String
  name: String
  mediaId: ID

  """
  An optional URL for a thumbnail or preview image for
  this object. If the URL is to an object in Veritone's
  object storage, it will be signed.
  """
  thumbnailUrl: String

  """
  An optional URL for a preview asset for this document
  object. If the URL is to an object in Veritone's
  object storage, it will be signed.
  """
  previewUrl: String

  """
  An optional URL for a source image for this object.
  If the URL is to an object in Veritone's
  object storage, it will be signed.
  """
  sourceImageUrl: String

  """Modular metadata"""
  metadata: [Metadata]

  """Direct access to metadata in raw JSON format"""
  jsondata: JSON
  details(
    """
    optionally, specify a path to retrieve only a specific property
    within the details JSON
    """
    path: String
  ): JSON

  """
  Assets this object contains. Can be of any size.
  This field does not support paging.
  """
  assets(
    """Provide an ID to retrieve a single asset."""
    id: ID

    """
    Specify a list of asset types such as "media" or "transcript" to
    retrieve a specific asset type
    """
    type: [String!]

    """Deprecated -- use type parameter"""
    assetType: [String!]

    """Retrieve assets created by a specific task"""
    sourceTaskId: ID

    """
    Provide an offset to skip to a certain element in the result, for paging.
    """
    offset: Int = 0

    """
    Specify maximum number of results to retrieve in this result. Page size.
    """
    limit: Int = 30
    orderBy: AssetOrderBy = createdDateTime
    orderDirection: OrderDirection = desc

    """
    Whether or not to include a virtual media asset
    that streams together all segments on a segmented
    TDO. Most clients should use the default for this.
    """
    includeVirtualMediaAsset: Boolean = true
  ): AssetList
  assetCount: Int!

  """Retrieve the primary asset of a given type"""
  primaryAsset(assetType: String!): Asset

  """Security settings for the asset container"""
  security: Security

  """Recording start time. In seconds since epoch."""
  startDateTime: DateTime!

  """Recording stop time. In seconds since epoch."""
  stopDateTime: DateTime!
  source: String

  """Application this recording belongs to"""
  applicationId: ID!

  """status. Downloaded, recording, etc."""
  status: String

  """Tasks running against this TemporalDataObject"""
  tasks(
    id: ID
    offset: Int = 0
    limit: Int = 30
    hasSourceAsset: Boolean

    """
    If a filter is not provided, a default of `createdDateTime` between
    the TDO creation time and the current date will be applied.
    """
    dateTimeFilter: [TaskDateTimeFilter]
  ): TaskList

  """Jobs running against this temporalDataObject"""
  jobs: JobList

  """Folders that this TDO is filed in"""
  folders: [Folder!]
  sourceData: TDOSourceData

  """
  If this TDO supports streams, contains stream listings.
  Might be an empty list but will not be null.
  """
  streams: [TDOStreamData!]!

  """Statuses of the engines run on the TDO."""
  engineRuns(offset: Int = 0, limit: Int = 100): EngineRunList

  """
  If this is a segmented TDO, returns the stream manifest
  contents in normalized JSON form.
  """
  streamManifest: TDOStreamManifest
}

enum TemporalDataObjectDateTimeField {
  createdDateTime
  modifiedDateTime
  startDateTime
  stopDateTime
}

"""
Specify a filter on a TemporalDataObject date/time field.
At least one of `toDateTime` and `fromDateTime` must be provided.
"""
input TemporalDataObjectDateTimeFilter {
  """Match if the field value is `toDateTime` or earlier"""
  toDateTime: DateTime

  """
  Whether the toDateTime is inclusive or exclusive of the input timestamp
  """
  toDateTimeExclusive: Boolean = false

  """Match if the field value is `fromDateTime` or later"""
  fromDateTime: DateTime

  """
  Whether the fromDateTime is inclusive or exclusive of the input timestamp
  """
  fromDateTimeExclusive: Boolean = false

  """Identify the field to filter on."""
  field: TemporalDataObjectDateTimeField!
}

enum TemporalDataObjectOrderBy {
  createdDateTime
  modifiedDateTime
  startDateTime
  stopDateTime
}

"""Time-only custom scalar type"""
scalar Time

"""Information about a time zone"""
type TimeZone {
  """Time zone name, such as `America/Los_Angeles`"""
  name: String!

  """
  Known abbreviations for the time zone. These may include
  offset variations such as those caused by daylight savings time.
  """
  abbreviations: [TimeZoneAbbreviation!]!
}

"""Information about a time zone abbreviation or variant."""
type TimeZoneAbbreviation {
  """
  The abbreviation, such as "PST" or "UTC"
  """
  name: String!

  """The offset from UTC in string form, such as `-08:00` for `PST`."""
  offset: String

  """The offset from UTC in minutes, such as `-480` for `PST`."""
  offsetMinutes: Int
}

type Token {
  """The token ID"""
  id: String
  applicationId: String
  groupId: String
  json: TokenJson
}

type TokenJson {
  rights: [String]
}

enum TokenType {
  API
  User
}

"""The possible transformer functions which can be used with assets"""
enum TransformFunction {
  """Transform asset with XML format to JSON"""
  XML2JSON

  """Transfrom asset with XML Transcript format to JSON"""
  Transcript2JSON

  """Get asset JSON data as JSON"""
  JSON
}

"""Contains information of a event hook"""
type Trigger {
  id: ID!
  event: String!
  target: String!
  consumerParams: JSON
  createdDateTime: DateTime!
  modifiedDateTime: DateTime!
  createdBy: String!
  updatedBy: String!
}

input UnfileTemporalDataObject {
  """ID of the TDO to unfile"""
  tdoId: ID!

  """ID of the parent folder. The TDO will be removed from this folder."""
  folderId: ID!
}

input UnfileWatchlist {
  """ID of the watchlist to unfile"""
  watchlistId: ID!

  """
  ID of the parent folder. The watchlist will be removed from this folder.
  """
  folderId: ID!
}

input UnpauseCluster {
  id: ID!
}

input UnpauseClusterNode {
  """Node ID"""
  id: ID!
}

type UnsubscribeEvent {
  """ID of the object that was deleted"""
  id: ID!

  """Message"""
  message: String
}

input UpdateApplication {
  id: ID!
  name: String
  status: ApplicationStatus
  category: String
  description: String
  iconUrl: String
  iconSvg: String
  url: String
  oauth2RedirectUrls: [String!]
  checkPermissions: Boolean
  permissionsRequired: [String!]
  deploymentModel: DeploymentModel
  contextMenuExtensions: UpdateContextMenuExtensions
}

"""
Input needed to update an asset. The asset data itself -- file or URI --
is immutable. Only supplemental metadata can be updated with this input type.
"""
input UpdateAsset {
  """The asset ID. Required."""
  id: ID!

  """The asset description."""
  description: String

  """File name or other name for the asset"""
  name: String

  """Optionally, set attributes about the file"""
  fileData: SetAssetFileData

  """Optionally, set attributes about the source engine and task"""
  sourceData: SetAssetSourceData

  """Application- or type-specific metadata"""
  details: JSON
}

input UpdateBuild {
  id: ID!
  engineId: ID!
  action: BuildUpdateAction!
  dockerImage: String
}

input updateBundleStatusAsCluster {
  """Id of the cluster."""
  clusterId: ID!

  """Id of the bundle."""
  bundleId: ID!

  """Bundle status body object"""
  bundleStatus: BundleStatus!
}

input UpdateCluster {
  id: ID!
  name: String
  allowedEngines: [String]
  dockerCredentials: JSON
  containerTag: String
  memorySize: Int
  storageSize: Int
  bypassAllowedEngines: Boolean

  """
  Permissions granted to other organizations. Only the cluster owner
  can view or edit this field.
  """
  collaborators: [CreateClusterCollaborator!]

  """Tags for cluster"""
  tags: [String]
  status: ClusterStatus

  """Update the cluster config"""
  clusterConfig: JSON

  """Media storage path. Optional -- use only for edge."""
  mediaStoragePath: String

  """
  Designate a management node ID. Used only for edge/portable clusters.
  Must be the ID of an existing node in the cluster.
  """
  managementNodeID: ID

  """
  Optionally, specify a time at which the edge cluster should
  be restarted daily. Applies only to edge clusters.
  """
  restartTimeUTC: Time

  """Update subscriptions on the cluster."""
  subscriptions: [UpdateClusterSubscription]

  """Optionally, specify an api-token for cluster"""
  serviceToken: String
}

input UpdateClusterNode {
  id: ID!
  name: String

  """Update the cluster node config"""
  nodeConfig: JSON
}

"""Updates the state information for a given cluster"""
input UpdateClusterState {
  """The cluster ID"""
  id: ID!
  state: JSON!

  """Optionally, update current the cluster status."""
  targetStatus: ClusterStatus
}

input UpdateClusterSubscription {
  userId: ID!
  isActive: Boolean
}

input UpdateCognitiveSearch {
  id: ID!
  profile: JSON
  jsonstring: String
  mentionStatusId: ID
}

input UpdateCollection {
  """id of the collection"""
  folderId: ID!

  """the name of the collection"""
  name: String

  """description of the collection"""
  folderDescription: String

  """Collection image"""
  image: String
}

input UpdateContextMenuExtension {
  id: ID
  label: String!
  url: String!
}

input UpdateContextMenuExtensions {
  mentions: [UpdateContextMenuExtension] = []
  tdos: [UpdateContextMenuExtension] = []
  watchlists: [UpdateContextMenuExtension] = []
  collections: [UpdateContextMenuExtension] = []
}

input UpdateCreative {
  id: ID!
  name: String
  keywords: String
  brandId: ID
  advertiserId: ID
}

input UpdateCurrentUser {
  """Required if updating the MFA phone number"""
  passwordToken: String

  """New MFA info for the current user, optional"""
  mfaInfo: UpdateMFAInfo

  """New user settings for the current user, optional"""
  userSetting: UserSettingInfo

  """New first name for the current user, optional"""
  firstName: String

  """New last name for the current user, optional"""
  lastName: String

  """New image URL for the current user, optional"""
  imageUrl: String
}

input UpdateDataRegistry {
  id: ID!
  name: String!
  description: String!
  source: String!
}

input UpdateDatasetConfidence {
  """
  Mininum Confidence Filter. Ignore sources having confidence lower than this
  """
  min: Float

  """
  Maximum Confidence Filter. Ignore sources having confidence higher than this
  """
  max: Float

  """allow sources with null confidence values"""
  allowNull: Boolean
}

"""Input fields used to update an existing engine."""
input UpdateEngine {
  """Supply the ID of the engine to update"""
  id: ID!

  """
  Indicates whether or not the engine should be public -- visible to and
  usable by users outside the creator's organization.
  Typically an engine should not be made public until it has been fully
  configured and tested in production.
  """
  isPublic: Boolean

  """
  Human-readable name for the engine. Changing this value will change
  how the engine appears to users.
  """
  name: String
  description: String
  categoryId: String

  """
  The engine deployment model. See the DeploymentModel enum for options.
  """
  deploymentModel: DeploymentModel

  """An optional price indicator for the engine."""
  price: Int

  """
  Optionally, supply custom fields that the user can set when launching
  the engine. See developer documentation for details. To update the fields,
  make sure you supply the complete set of new fields -- new fields,
  updated existing fields, and unmodified existing fields.
  """
  fields: [CreateEngineField!]

  """The path for an icon image"""
  iconPath: String

  """The path for a logo image"""
  logoPath: String

  """Whether or not the engine requires a library."""
  libraryRequired: Boolean
}

input UpdateEngineConfiguration {
  id: ID!
  credentialIds: [ID!]
}

input UpdateEngineDependency {
  """
  The category type this engine depends on.
  Must be a valid categoryType from an existing EngineCategory.
  """
  dependencyType: String

  """
  An optional asset type that the engine will expect to have
  been created.
  """
  assetType: String
}

input UpdateEntity {
  id: ID!
  name: String
  description: String
  profileImageUrl: String

  """
  GraphQL-formatted JSON-like structure containing freeform metadata.
  If a schema is associated with the entity type, the input will be
  validated against the schema. Use this field _or_ `jsonstring`, not both.
  """
  jsondata: JSON

  """
  A string containing valid JSON with freeform metadata.
  If a schema is associated with the entity type, the input will be
  validated against the schema. Use this field _or_ `jsondata`, not both.
  """
  jsonstring: String
}

input UpdateEntityIdentifier {
  id: ID!
  title: String
  isPriority: Boolean
  url: String

  """
  GraphQL-formatted JSON-like structure containing freeform metadata.
  If a schema is associated with the entity type, the input will be
  validated against the schema. Use this field _or_ `jsonstring`, not both.
  """
  jsondata: JSON

  """
  A string containing valid JSON with freeform metadata.
  If a schema is associated with the entity type, the input will be
  validated against the schema. Use this field _or_ `jsondata`, not both.
  """
  jsonstring: String
}

input UpdateEntityIdentifierType {
  id: ID!
  label: String
  labelPlural: String
  iconClass: String
  description: String
  dataType: EntityIdentifierDataType
}

input UpdateEntityType {
  name: String
  namePlural: String
  schema: JSON
}

input UpdateEvent {
  """ID of event"""
  id: ID!

  """General description of the event"""
  description: String
}

type UpdateExecutionLocation {
  id: ID!
  clusterId: ID!
  nodeId: ID
}

input UpdateExportRequest {
  """ID of the export request to update"""
  id: ID!

  """Status change"""
  status: ExportRequestStatus

  """The asset URI"""
  assetUri: String
}

input UpdateExternalCredential {
  id: ID!
  dataId: ID
}

"""
Information required to update a folder.
Currently, the folder can be renamed. No other changes are supported.
"""
input UpdateFolder {
  """ID of the folder to update"""
  id: ID!

  """New name for the folder."""
  name: String!
}

input UpdateFolderContentTempate {
  """The ID of Folder Content Template"""
  id: ID!

  """The ID of folder"""
  folderId: ID

  """The ID of Structure Data Object"""
  sdoId: ID

  """The ID of Data Registry"""
  schemaId: ID
  data: JSON
}

input UpdateIngestionConfiguration {
  id: ID!
  type: String
  name: String

  """
  Container for arbitrary JSON-format metadata including configuration, etc.
  """
  jsondata: JSON

  """
  String containing raw JSON-format metadata. You can specify
  either this value or jsondata, but not both.
  """
  jsonstring: String
}

input UpdateJobPipeline {
  id: ID!
  jobTemplateIds: [ID!]
  isPublic: Boolean
}

input UpdateJobs {
  ids: [ID!]
  status: UpdateJobsStatus
}

enum UpdateJobsStatus {
  queued
}

input UpdateJobTemplate {
  id: ID!

  """taskTemplates: [CreateTaskTemplate!]"""
  jobPipelineStage: Int
  skipDecider: Boolean
  jobConfig: JSON
}

input UpdateLibrary {
  id: ID!
  name: String
  coverImageUrl: String
  description: String
  libraryTypeId: ID
  version: Int
}

input UpdateLibraryConfiguration {
  """library configuration id"""
  id: ID!

  """List of selected engines for training"""
  targetEngineIds: [ID]

  """
  This option is used for Dataset Library Only
  List of selected engine where tdos are extracted from for training data
  TDOs are extracted from higher ranked engines first then fallback to the lower
  ones if the priors don't have any matching tdo
  """
  rankedSourceEngineIds: [ID]

  """
  This option is used for Dataset Library Only
  Dataset TDOs confidence filters
  """
  confidence: UpdateDatasetConfidence
}

input UpdateLibraryEngineModel {
  """ID of the library engine model to update."""
  id: ID!

  """Id of the train job."""
  trainJobId: ID

  """Status of the train job."""
  trainStatus: LibraryEngineModelTrainStatus

  """
  The URL to a file containing or related to the engine model.
  Submit either this field _or_ `file`, not both.
  Use this field if the data is stored in a separate, internet-accessible
  location and not managed by Veritone APIs.
  """
  dataUrl: String

  """Optional free-form block containing engine-specific metadata."""
  jsondata: JSON

  """
  If a file is uploaded, you can explicitly specify the content type
  (a valid MIME type string) with this field. Often this is not necessary
  as the HTTP multipart form POST client will set content type on the
  file object implicitly.
  """
  contentType: String

  """
  An optional data file containing or related to the engine model.
  Use multipart form POST to submit this field.
  Submit either this field _or_ `dataUrl`, not both. If a file is
  uploaded, the server will store it and then set `dataUrl` to
  its location.
  """
  file: UploadedFile
  accuracy: Int
  configurationId: ID
}

input UpdateLibraryType {
  id: ID!
  label: String!
  iconClass: String
  entityIdentifierTypeIds: [ID!]
  entityType: UpdateEntityType
}

input UpdateMention {
  id: ID!
  privateNote: String
  publicNote: String
  complianceStatusId: ID
  spotTypeId: ID
  statusId: ID
  adCreative: JSON
  userSnippets: JSON
}

input UpdateMentionComment {
  mentionId: ID!
  commentId: ID!
  commentText: String!
}

input UpdateMentionExportRequest {
  """The required mentionExportRequestId will be used for update"""
  id: ID!

  """Status of mentionExportRequest record"""
  status: ExportRequestStatus

  """The asset URI"""
  assetUri: String
}

input UpdateMentionRating {
  mentionId: ID!
  ratingId: ID!
  ratingValue: Int!
}

input UpdateMentions {
  ids: [ID!]!
  statusId: ID
}

input UpdateMFAInfo {
  phoneNumber: String
}

"""Fields used to update an organization."""
input UpdateOrganization {
  """ID of the organization to update"""
  id: ID!

  """Name of the organization"""
  name: String
  type: String
  seatLimit: Int
  status: String
  applications: [ID!]
  businessUnit: String

  """Currently only Veritone administrators can modify this field."""
  metadata: JSON

  """
  Update the engine blacklist for this organization.
  Currently only Veritone administrators can modify this field.
  Updating this field will completely replacing the existing engine
  and engine category blacklists with the IDs provided.
  """
  blacklist: SetEngineBlacklist

  """
  Update the engine whitelist for this organization.
  Currently only Veritone administrators can modify this field.
  Updating this field will completely replacing the existing engine
  and whitelist with the IDs provided.
  """
  whitelist: SetEngineWhitelist
}

input UpdateProcessTemplate {
  id: ID!
  taskList: JSON!
}

input UpdateScheduledJob {
  id: ID!
  jobPipelineIds: [ID!]
  jobTemplateIds: [ID!]

  """Optionally, specify the job template definitions here."""
  jobTemplates: [CreateJobTemplate!]
  weeklyScheduleParts: [CreateWeeklySchedulePart!]
  recurringScheduleParts: [CreateRecurringSchedulePart!]
  name: String

  """A detailed description. Defaults to name."""
  description: String
  runMode: RunMode

  """
  JSON containing metadata details for this scheduled job.
  If the scheduled job does not already have a schema ID
  associated with, one must be supplied along with this data.
  In either case, the supplied data must comply with the
  schema.
  """
  details: JSON

  """ID of the schema for detail metadata on this scheduled job"""
  detailsSchemaId: ID
  isActive: Boolean
  startDateTime: DateTime
  stopDateTime: DateTime

  """Optionally, associate content templates with the new scheduled job"""
  contentTemplates: [CreateScheduledJobContentTemplateWithScheduledJob!]

  """
  Indicates whether or not the scheduled job is publicly accessible.
  Only Veritone administrators can create public scheduled jobs.
  Other users will get an error if they attempt to set this value to true.
  """
  isPublic: Boolean = false
  affiliates: [CreateProgramAffiliate!]

  """
  Indicates whether or not the scheduled job we should upgrade this schedule job
  to the new data model if an upgrade is possible.
  """
  migrateIfLegacy: Boolean = false
}

input UpdateSchemaState {
  """The schemaId to update"""
  id: ID!

  """The new schema status"""
  status: SchemaStatus!

  """Specify if publishing this schema would break ingestion"""
  breakingChanges: Boolean = false
}

"""Data used to update an existing source"""
input UpdateSource {
  """The ID of the source to update"""
  id: ID!

  """Update the name field"""
  name: String

  """Update the isPublic field"""
  isPublic: Boolean

  """
  Additional metadata to associate with the source. This data may be
  validated against a schema associated with the source type.
  """
  details: JSON

  """Optional thumbnail image URL for the source"""
  thumbnailUrl: String

  """Optionally, associate content templates with the new source"""
  contentTemplates: [CreateSourceContentTemplateWithSource!]

  """
  Optionally associate a schema for correlation.
  Required when correlationSDOId is specified.
  """
  correlationSchemaId: ID

  """
  Optionally associate a structured data object of the specified correlationSchemaId.
  Required when correlationSchemaId is specified.
  """
  correlationSDOId: ID

  """
  Add or modify collaborators on the source. Permissions for organizations
  not mentioned in this list will _not_ be modified. To revoke permissions
  for an organization, use the `none` permission.
  """
  collaborators: [CreateSourceCollaborator!]

  """
  Set current state for the source. This is used only by the adapters
  that use the source and should not be set by other clients.
  """
  state: JSON
}

input UpdateSourceType {
  id: ID!
  name: String
  sourceSchemaId: ID
  credentialSchemaId: ID
  details: JSON
  credentialType: CredentialType

  """
  Indicates that the source type is publicly accessible.
  If false, is usable only by the owner organization.
  """
  isPublic: Boolean

  """
  Indicates whether or not the source type is "live", such
  as a camera feed
  """
  isLive: Boolean

  """
  Indicates whether or not the source type requires
  scan pipeline jobs
  """
  requiresScanPipeline: Boolean = false

  """Source type category ID"""
  categoryId: ID
}

input UpdateSubscription {
  id: ID!
}

input UpdateTask {
  id: ID!
  status: TaskStatus!
  jobId: ID
  output: JSON

  """Task output as JSON string"""
  outputString: String

  """ Use this parameter if your task output does not take the form of valid
   JSON. Provide a key and the server will convert your output into
   JSON with a single string value. For example,
   ```
     mutation {
       updateTask(input: {
         id: <id>
         outputString: "<xml><stuff id=\"value\">more stuff </stuff></xml>"
         outputJsonKey: "response"
       }) { id }
     }
  
   ```
   Will set the task output JSON to
    ` {"response":"<xml><stuff id=\"value\">more stuff </stuff></xml>"}`
  """
  outputJsonKey: String

  """Backwards compatibility only"""
  taskOutput: JSON

  """Update the task with a new payload"""
  payload: JSON

  """Save execution location metadata"""
  executionLocationData: JSON

  """
  Optional timestamp used to control change ordering.
  The client may set this to the `modifiedDateTime` value
  of most recent copy of the task it has before making the
  update. The server will _only_ update the task with the
  requested changes _if_ and only if the current
  `modifiedDateTime` value is equal to or earlier than
  the supplied `clientTimestamp` value. Thus, changes
  that were made after the client last retrieved the task
  data will not be overwritten.
  """
  clientTimestamp: DateTime

  """
  A code indicating why the task failed. Should be set
  if and only if task status is `failed`.
  If set with any other task status, the API will return an error.
  """
  failureReason: TaskFailureReason

  """
  A human-readable string with detail on the
  task failure reason. Should be set if and only if
  task status is `failed` and `failureReason` is set.
  If set with any other task status or if `failureReason` is not set,
  the API will return an error.
  """
  failureMessage: String
}

enum UpdateTaskStatus {
  running
  failed
  complete
  waiting
}

input UpdateTaskTemplate {
  id: ID!
  payload: JSON
  payloadString: String
  parentTaskId: ID
}

"""Payload required to create a temporal data object"""
input UpdateTDO {
  """ID of the TDO to update"""
  id: ID!

  """Start date and time in numerical (epoch) format."""
  startDateTime: DateTime

  """Stop date and time in numerical (epoch) format."""
  stopDateTime: DateTime

  """Source for the TDO, such as an ingestion type or engine ID."""
  source: String

  """Current status, such as "downloaded" or "recording"."""
  status: String

  """
  A name for the TDO object, such as the name of the primary media file.
  """
  name: String

  """A description for the TDO object."""
  description: String

  """Set the primary asset of a given type (transcript or media)"""
  primaryAsset: [SetPrimaryAsset!]

  """
  True if the new TDO should be made public. If true, security.global
  will be set to true and users from other organizations will be able to
  view, but not modify, the TDO's metadata and assets.
  """
  isPublic: Boolean
  details: JSON

  """
  Optionally, specify one or more structured data objects to apply as
  content templates to the TDO. They will be stored as assets of type
  content-template and will contain an immutable copy of the original data.
  Setting this field on an update does _not_ affect any content templates
  previously added to the TDO -- it only creates the new ones.
  """
  contentTemplates: [CreateTDOContentTemplateWithTDO!]

  """An optional thumbnail URL for the TDO"""
  thumbnailUrl: String

  """An optional preview asset URL for the TDO"""
  previewUrl: String

  """An optional image representing the TDO source"""
  sourceImageUrl: String
}

input UpdateUser {
  id: ID!
  name: String
  jsondata: JSON
  roleIds: [ID!]
  acls: [UserACLInput!]

  """Optionally, specify user's first name"""
  firstName: String

  """Optionally, specify user's last name"""
  lastName: String
}

input UpdateWatchlist {
  id: ID!
  startDateTime: DateTime
  stopDateTime: DateTime
  name: String
  sourceTypeIds: [ID!]

  """
  Set structured metadata on the watchlist.
  The data is subject to a set of schemas.
  """
  details: JSON
  searchIndex: SearchIndex
  parentFolderId: ID
  sourceIds: [ID!]
  subscriptions: [CreateSubscriptionInWatchlist!]
  cognitiveSearches: [CreateCognitiveSearchInWatchlist!]
}

input UpdateWidget {
  id: ID!
  name: String
  adScript: String
  width: Int
  numberOfMentionsToShow: Int
  displayLogo: Boolean
  displayCollectionName: Boolean
  displayMentionIntro: Boolean
  displayTranscription: Boolean
  displayCollectionDescription: Boolean
  displayMentionDescription: Boolean
  seoTags: [String]
  backgroundColor: String
  borderColor: String
  textColor: String
  createdDateTime: DateTime
  nextButtonColor: String
}

"""
A custom scalar type representing a file upload in the asset input types
"""
scalar UploadedFile

"""
Fields needed to upload and store an engine result using multipart form POST.
"""
input UploadEngineResult {
  """ID of the task that created this engine result"""
  taskId: ID!

  """
  A string containing the engine result.
  Use either this field, `output`, `uri`, or `file` with multipart form POST, but not
  more than one.
  """
  outputString: String

  """
  JSON data containing the engine result.
  A string containing the engine result.
  Use either this field, `outputString`, `uri`, or `file` with multipart form POST, but not
  more than one.
  """
  output: JSON

  """
  A file to upload. Use multipart form POST to submit this field.
  Use this field, the `output`, `outputString`, or `uri` field, not more than one.
  """
  file: UploadedFile

  """
  A URI to the file. Use one and only one of `uri`, `file`, or `output`/`outputString`.
  """
  uri: String

  """The file name"""
  filename: String

  """
  The type of asset to create. Optional -- if not set, it will be
  deduced from the engine category.
  """
  assetType: String

  """
  The content type of the file. Optional -- if not set, it will
  be deduced from the file name.
  """
  contentType: String

  """Whether or not to mark the task as complete. Defaults to true."""
  completeTask: Boolean = true

  """
  If the result data uploaded is not a valid JSON string, then
  the task output data stored on the task object will be wrapped into
  a JSON object using this key. The asset created, however, is not
  modified in any way.
  """
  outputJsonKey: String = "data"

  """Optionally, set attributes about the file"""
  fileData: SetAssetFileData

  """
  if true, sets the new asset to be the primary asset of its type.
  Only certain asset types, such as "media" and "transcript",
  can have primary assets.
  """
  setAsPrimary: Boolean = false

  """
  Skips indexing the engine result, preventing mentions from being
  generated over the results.
  """
  skipIndexing: Boolean = false

  """
  Whether or not to set the legacy `task_output` data for compatible
  with older clients.
  """
  setTaskOutput: Boolean = true
}

input UpsertSchemaDraft {
  dataRegistryId: ID!
  majorVersion: Int = 1
  schema: JSON!
}

"""A user represents a user account within an organization."""
type User {
  """The user's name"""
  name: String!

  """
  The user's unique ID.
  A user ID is a string in UUID format.
  """
  id: ID!

  """The set of permissions granted to the user"""
  permissions: PermissionList

  """The set of roles granted to the user"""
  roles: [Role!]
  roleIds: [ID!]

  """ID of the organization to which the user belongs."""
  organizationId: ID

  """Organization to which the user belongs."""
  organization: Organization

  """Freeform metadata in JSON form"""
  jsondata: JSON
  firstName: String
  lastName: String
  email: String
  acls: [UserACL!]

  """Folder tree for this organization"""
  rootFolder(
    """Specify a root folder type to retrieve a specific root folder"""
    type: RootFolderType = watchlist
  ): Folder

  """Date and time this user last changed their password"""
  passwordUpdatedDateTime: DateTime

  """Date and time this user last logged in"""
  lastLoginDateTime: DateTime

  """Date and time this user account was created"""
  createdDateTime: DateTime

  """Date and time this user account was last modified"""
  modifiedDateTime: DateTime

  """Multi-factor authentication information for the user"""
  mfaInfo: MFAInfo!

  """User Settings for the user"""
  userSettings: [UserSetting!]
  imageUrl: String

  """Status of user account"""
  status: UserStatus
}

type UserACL {
  applicationId: ID
  organizationId: ID
  organization: Organization
  objectType: String
  objectId: String
  access: UserACLAccessRights
  userId: ID
}

type UserACLAccessRights {
  owner: Boolean
}

input UserACLAccessRightsInput {
  owner: Boolean
}

input UserACLInput {
  applicationId: ID
  organizationId: ID
  objectType: String
  objectId: String
  access: UserACLAccessRightsInput
  userId: ID
}

type UserList implements Page {
  records: [User]

  """The starting index for records that were returned in this query."""
  offset: Int!

  """
  Maximum number of results that were retrieved in this query; page size
  """
  limit: Int!

  """Number of records returned in this response"""
  count: Int
}

"""Input fields required by the userLogin mutation."""
input UserLogin {
  """The user login name -- typically, email address."""
  userName: String!

  """
  The user password. Note that this value is only ever transmitted over
  the encrypted SSL protocol.
  """
  password: String!
}

"""Type that holds user setting for a user"""
type UserSetting {
  key: String
  value: String
}

input UserSettingInfo {
  key: String
  value: String
}

enum UserStatus {
  active
  suspended
  deleted
}

type VerifyJWTPayload {
  """the same JWT input"""
  jwtToken: String!

  """the payload contained within the JWT"""
  payload: JSON!
}

type Watchlist {
  """The primary ID"""
  id: ID!

  """A human-readable name for the watchlist"""
  name: String!

  """The organization that owns the watchlist"""
  organization: Organization!

  """ID of the organization that owns the watchlist"""
  organizationId: ID!

  """IDs of the schedules associated with the watchlist"""
  scheduleIds: [ID!]

  """Date and time at which the watchlist takes effect"""
  startDateTime: DateTime

  """Date and time at which the watchlist is no longer in effect"""
  stopDateTime: DateTime

  """Date and time the watchlist was created"""
  createdDateTime: DateTime

  """Date and time the watchlist was last modified"""
  modifiedDateTime: DateTime

  """Cognitives searches associated with the watchlist"""
  cognitiveSearches: [CognitiveSearch!]

  """Ids of the source types associated directly with the watchlist"""
  sourceTypeIds: [ID!]

  """IDs of the sources associated directly with the watchlist"""
  sourceIds: [ID!]

  """
  Folders that the watchlist is filed in.
  At present, a watchlist can only be filed in a single folder.
  """
  folders: [Folder!]

  """
  Structured metadata associated with the watchlist.
  Elements of the metadata are validated against specific schemas.
  """
  details: JSON
  subscriptions: [Subscription!]!
  searchIndex: SearchIndex!
  query: JSON

  """Get mentions generated for this watchlist"""
  mentions(offset: Int = 0, limit: Int = 30): MentionList

  """ID of the advertiser directly with the watchlist"""
  advertiserId: ID

  """ID of the brand directly with the watchlist"""
  brandId: ID

  """advertiser associated with the watchlist"""
  advertiser: JSON

  """brand associated with the watchlist"""
  brand: JSON

  """creative associated with the watchlist"""
  creative: Creative

  """
  Contains the list of all source type IDs
  associated with this watchlist, including
  those for sources on schedules.
  """
  combinedSourceTypeIds: [ID!]
  scheduledJobs(offset: Int = 0, limit: Int = 30): ScheduledJobList!

  """TODO for backward compat with v3 search?"""
  schedules(offset: Int = 0, limit: Int = 30): ScheduledJobList!
}

type WatchlistList implements Page {
  records: [Watchlist]

  """
  Provide an offset to skip to a certain element in the result, for paging.
  """
  offset: Int!

  """
  Maximum number of results that were retrieved in this query; page size
  """
  limit: Int!

  """Number of records returned in this response"""
  count: Int
}

enum WatchlistOrderBy {
  createdDateTime
  modifiedDateTime
  stopDateTime
  startDateTime
  name
}

type Widget {
  id: ID
  name: String
  organization: Organization
  organizationId: ID
  collection: Collection
  collectionId: ID!
  displayCollectionName: Boolean
  displayCollectionDescription: Boolean
  displayTranscription: Boolean
  displayMentionDescription: Boolean
  displayMentionIntro: Boolean
  displayLogo: Boolean
  width: Int
  numberOfMentionsToShow: Int
  adScript: String
  seoTags: [String]
  backgroundColor: String
  borderColor: String
  textColor: String
  nextButtonColor: String
  createdDateTime: DateTime
}

type WidgetList implements Page {
  records: [Widget]

  """
  Provide an offset to skip to a certain element in the result, for paging.
  """
  offset: Int!

  """
  Maximum number of results that were retrieved in this query; page size
  """
  limit: Int!

  """Number of records returned in this response"""
  count: Int
}

type WorkflowRuntimeResponse {
  success: Boolean!

  """Error message if success is false"""
  message: String

  """
  uri of veritone workflow instance.
  This is only available when Workflow request is successful
  """
  uri: String

  """Authentication token used for webhooks"""
  authToken: String
}

type WorkflowRuntimeStorageData {
  """Unique lookup id for the workflowRuntimeData"""
  storageKey: String!

  """Data content - base64 encoded binary, plain string or encoded JSON"""
  storageData: String!

  """Optional metadata for the workflowRuntimeData"""
  storageMetadata: String
}

type WorkflowRuntimeStorageDataList implements Page {
  records: [WorkflowRuntimeStorageData]
  count: Int
  offset: Int!
  limit: Int!
}

"""
Contains information about a signed writable URL retrieved from the
getSignedWritableUrl mutation.
"""
type WritableUrlInfo {
  """The storage bucket ID"""
  bucket: String!

  """The storage object key"""
  key: String!

  """
  Time interval, in seconds, after which this URL is expired and no longer valid.
  """
  expiresInSeconds: Int!

  """Absolute time at which this URL expires"""
  expiresAtDateTime: DateTime!

  """
  The signed URL, which can be uploaded to with an HTTP PUT (note:  PUT is
  required. POST will generate an error).
  """
  url: String!

  """
  A signed URL that can be used with HTTP GET to retrieve the
  new resource.
  """
  getUrl: String!

  """
  The unsigned, base URL to the object, which can be safely persisted
  and re-signed later by a client with the necessary storage credentials.
  """
  unsignedUrl: String
}

